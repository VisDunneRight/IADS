<script strictEvents>import { getContext, onMount, onDestroy, hasContext } from 'svelte';
import { KEY } from './Splitpanes.svelte';
import { browser } from './internal/env.js';
import { gatheringKey } from './internal/GatheringRound.svelte';
import { getDimensionName } from './internal/utils/sizing.js';
import { carefullCallbackObject } from './internal/utils/functions';
const { ssrRegisterPaneSize, onPaneInit, clientOnly: clientOnlyContext, isHorizontal, showFirstSplitter, veryFirstPaneKey } = getContext(KEY);
// PROPS
export let size = null;
export let minSize = 0;
export let maxSize = 100;
export let snapSize = 0;
// css class
let clazz = '';
export { clazz as class };
// VARIABLES
const key = {};
const gathering = !browser && hasContext(gatheringKey);
const { undefinedPaneInitSize } = (!gathering ? onPaneInit(key) : {});
let element;
let sz = size ?? undefinedPaneInitSize;
let isSplitterActive = false;
// CALLBACKS
let clientCallbacks = undefined;
/**
 * This is an object of callbacks that are safe to be called on browser even when the object `clientCallbacks`
 *  isn't initialized yet (i.e. before `onPaneAdd()`).
 *
 * In the case of the object isn't initialized yet, calling this callbacks will do nothing.
 */
const carefullClientCallbacks = browser
    ? carefullCallbackObject(() => clientCallbacks, [
        'onSplitterDown',
        'onSplitterClick',
        'onSplitterDblClick',
        'onPaneClick',
        'reportGivenSizeChange'
    ])
    : undefined;
// REACTIVE
const reportGivenSizeChangeSafe = (size) => {
    // We put an extra check of `size != sz` here and not in the reactive statement, since we don't want a change
    //  of `sz` to trigger report.
    if (size != sz) {
        carefullClientCallbacks.reportGivenSizeChange(size);
    }
};
$: {
    if (browser && size != null) {
        reportGivenSizeChangeSafe(size);
    }
}
$: dimension = getDimensionName($isHorizontal);
$: style = `${dimension}: ${sz}%;`;
const splitterAction = (splitter) => {
    splitter.onmousedown = carefullClientCallbacks.onSplitterDown;
    if ('ontouchstart' in window) {
        splitter.ontouchstart = carefullClientCallbacks.onSplitterDown;
    }
    splitter.onclick = carefullClientCallbacks.onSplitterClick;
    splitter.ondblclick = carefullClientCallbacks.onSplitterDblClick;
    // This what should be done on destruction, but commented out since the DOM element gets destroyed anyway
    // return {
    // 	destroy: () => {
    // 		splitter.onmousedown = null;
    // 		if ('ontouchstart' in window) {
    // 			splitter.ontouchstart = null;
    // 		}
    // 		splitter.onclick = null;
    // 		splitter.ondblclick = null;
    // 	},
    // };
};
if (gathering) {
    ssrRegisterPaneSize(size);
}
else if (browser) {
    onMount(() => {
        const inst = {
            key,
            element: element,
            givenSize: size,
            sz: () => sz,
            setSz: (v) => {
                sz = v;
                if (size != null && size != sz) {
                    size = sz;
                }
            },
            min: () => minSize,
            max: () => maxSize,
            snap: () => snapSize,
            setSplitterActive: (isActive) => {
                isSplitterActive = isActive;
            },
            isReady: false
        };
        clientCallbacks = clientOnlyContext.onPaneAdd(inst);
    });
    onDestroy(() => {
        clientOnlyContext.onPaneRemove(key);
    });
}
</script>

{#if !gathering}
	<!-- Splitter -->
	<!-- TODO: Support aria role="separator" and make this a focusable separtor. Sources:
	* https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/roles/separator_role
	* https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/
-->
	{#if $veryFirstPaneKey !== key || $showFirstSplitter}
		<div use:splitterAction class="splitpanes__splitter {isSplitterActive ? 'splitpanes__splitter__active' : ''}" />
	{/if}

	<!-- Pane -->
	<div
		class={`splitpanes__pane ${clazz || ''}`}
		bind:this={element}
		on:click={carefullClientCallbacks.onPaneClick}
		{style}
	>
		<slot />
	</div>
{/if}
