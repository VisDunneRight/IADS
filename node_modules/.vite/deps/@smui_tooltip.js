import {
  getCorrectPropertyName
} from "./chunk-5XZPH2TV.js";
import {
  AnimationFrame
} from "./chunk-4LU6W7XY.js";
import {
  classAdderBuilder
} from "./chunk-EX5BY7X7.js";
import {
  KEY,
  MDCComponent,
  MDCFoundation,
  __assign,
  __extends,
  __values,
  normalizeKey
} from "./chunk-FH6GA4EX.js";
import "./chunk-3YX7D5QD.js";
import {
  classMap,
  dispatch,
  exclude,
  forwardEventsBuilder,
  prefixFilter,
  useActions
} from "./chunk-SALMN5C5.js";
import {
  writable
} from "./chunk-DY7FSUYH.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_dev,
  assign,
  binding_callbacks,
  check_outros,
  component_subscribe,
  compute_rest_props,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_update,
  group_outros,
  init,
  insert_dev,
  is_function,
  listen_dev,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_store_value,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-K6MJRMI7.js";
import "./chunk-FAW2VN4A.js";

// node_modules/@material/tooltip/constants.js
var CssClasses;
(function(CssClasses2) {
  CssClasses2["RICH"] = "mdc-tooltip--rich";
  CssClasses2["SHOWN"] = "mdc-tooltip--shown";
  CssClasses2["SHOWING"] = "mdc-tooltip--showing";
  CssClasses2["SHOWING_TRANSITION"] = "mdc-tooltip--showing-transition";
  CssClasses2["HIDE"] = "mdc-tooltip--hide";
  CssClasses2["HIDE_TRANSITION"] = "mdc-tooltip--hide-transition";
  CssClasses2["MULTILINE_TOOLTIP"] = "mdc-tooltip--multiline";
  CssClasses2["SURFACE"] = "mdc-tooltip__surface";
  CssClasses2["SURFACE_ANIMATION"] = "mdc-tooltip__surface-animation";
  CssClasses2["TOOLTIP_CARET_TOP"] = "mdc-tooltip__caret-surface-top";
  CssClasses2["TOOLTIP_CARET_BOTTOM"] = "mdc-tooltip__caret-surface-bottom";
})(CssClasses || (CssClasses = {}));
var numbers = {
  BOUNDED_ANCHOR_GAP: 4,
  UNBOUNDED_ANCHOR_GAP: 8,
  MIN_VIEWPORT_TOOLTIP_THRESHOLD: 8,
  HIDE_DELAY_MS: 600,
  SHOW_DELAY_MS: 500,
  // LINT.IfChange(tooltip-dimensions)
  MIN_HEIGHT: 24,
  MAX_WIDTH: 200,
  // LINT.ThenChange(_tooltip.scss:tooltip-dimensions)
  CARET_INDENTATION: 24,
  // LINT.IfChange(tooltip-anim-scale)
  ANIMATION_SCALE: 0.8
  // LINT.ThenChange(_tooltip.scss:tooltip-anim-scale)
};
var attributes = {
  ARIA_EXPANDED: "aria-expanded",
  ARIA_HASPOPUP: "aria-haspopup",
  PERSISTENT: "data-mdc-tooltip-persistent",
  SCROLLABLE_ANCESTOR: "tooltip-scrollable-ancestor",
  HAS_CARET: "data-mdc-tooltip-has-caret"
};
var events = {
  HIDDEN: "MDCTooltip:hidden"
};
var XPosition;
(function(XPosition2) {
  XPosition2[XPosition2["DETECTED"] = 0] = "DETECTED";
  XPosition2[XPosition2["START"] = 1] = "START";
  XPosition2[XPosition2["CENTER"] = 2] = "CENTER";
  XPosition2[XPosition2["END"] = 3] = "END";
})(XPosition || (XPosition = {}));
var YPosition;
(function(YPosition2) {
  YPosition2[YPosition2["DETECTED"] = 0] = "DETECTED";
  YPosition2[YPosition2["ABOVE"] = 1] = "ABOVE";
  YPosition2[YPosition2["BELOW"] = 2] = "BELOW";
})(YPosition || (YPosition = {}));
var AnchorBoundaryType;
(function(AnchorBoundaryType2) {
  AnchorBoundaryType2[AnchorBoundaryType2["BOUNDED"] = 0] = "BOUNDED";
  AnchorBoundaryType2[AnchorBoundaryType2["UNBOUNDED"] = 1] = "UNBOUNDED";
})(AnchorBoundaryType || (AnchorBoundaryType = {}));
var strings = {
  LEFT: "left",
  RIGHT: "right",
  CENTER: "center",
  TOP: "top",
  BOTTOM: "bottom"
};
var PositionWithCaret;
(function(PositionWithCaret2) {
  PositionWithCaret2[PositionWithCaret2["DETECTED"] = 0] = "DETECTED";
  PositionWithCaret2[PositionWithCaret2["ABOVE_START"] = 1] = "ABOVE_START";
  PositionWithCaret2[PositionWithCaret2["ABOVE_CENTER"] = 2] = "ABOVE_CENTER";
  PositionWithCaret2[PositionWithCaret2["ABOVE_END"] = 3] = "ABOVE_END";
  PositionWithCaret2[PositionWithCaret2["TOP_SIDE_START"] = 4] = "TOP_SIDE_START";
  PositionWithCaret2[PositionWithCaret2["CENTER_SIDE_START"] = 5] = "CENTER_SIDE_START";
  PositionWithCaret2[PositionWithCaret2["BOTTOM_SIDE_START"] = 6] = "BOTTOM_SIDE_START";
  PositionWithCaret2[PositionWithCaret2["TOP_SIDE_END"] = 7] = "TOP_SIDE_END";
  PositionWithCaret2[PositionWithCaret2["CENTER_SIDE_END"] = 8] = "CENTER_SIDE_END";
  PositionWithCaret2[PositionWithCaret2["BOTTOM_SIDE_END"] = 9] = "BOTTOM_SIDE_END";
  PositionWithCaret2[PositionWithCaret2["BELOW_START"] = 10] = "BELOW_START";
  PositionWithCaret2[PositionWithCaret2["BELOW_CENTER"] = 11] = "BELOW_CENTER";
  PositionWithCaret2[PositionWithCaret2["BELOW_END"] = 12] = "BELOW_END";
})(PositionWithCaret || (PositionWithCaret = {}));
var YPositionWithCaret;
(function(YPositionWithCaret2) {
  YPositionWithCaret2[YPositionWithCaret2["ABOVE"] = 1] = "ABOVE";
  YPositionWithCaret2[YPositionWithCaret2["BELOW"] = 2] = "BELOW";
  YPositionWithCaret2[YPositionWithCaret2["SIDE_TOP"] = 3] = "SIDE_TOP";
  YPositionWithCaret2[YPositionWithCaret2["SIDE_CENTER"] = 4] = "SIDE_CENTER";
  YPositionWithCaret2[YPositionWithCaret2["SIDE_BOTTOM"] = 5] = "SIDE_BOTTOM";
})(YPositionWithCaret || (YPositionWithCaret = {}));
var XPositionWithCaret;
(function(XPositionWithCaret2) {
  XPositionWithCaret2[XPositionWithCaret2["START"] = 1] = "START";
  XPositionWithCaret2[XPositionWithCaret2["CENTER"] = 2] = "CENTER";
  XPositionWithCaret2[XPositionWithCaret2["END"] = 3] = "END";
  XPositionWithCaret2[XPositionWithCaret2["SIDE_START"] = 4] = "SIDE_START";
  XPositionWithCaret2[XPositionWithCaret2["SIDE_END"] = 5] = "SIDE_END";
})(XPositionWithCaret || (XPositionWithCaret = {}));

// node_modules/@material/tooltip/foundation.js
var RICH = CssClasses.RICH;
var SHOWN = CssClasses.SHOWN;
var SHOWING = CssClasses.SHOWING;
var SHOWING_TRANSITION = CssClasses.SHOWING_TRANSITION;
var HIDE = CssClasses.HIDE;
var HIDE_TRANSITION = CssClasses.HIDE_TRANSITION;
var MULTILINE_TOOLTIP = CssClasses.MULTILINE_TOOLTIP;
var AnimationKeys;
(function(AnimationKeys2) {
  AnimationKeys2["POLL_ANCHOR"] = "poll_anchor";
})(AnimationKeys || (AnimationKeys = {}));
var HAS_WINDOW = typeof window !== "undefined";
var MDCTooltipFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCTooltipFoundation2, _super);
    function MDCTooltipFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCTooltipFoundation2.defaultAdapter), adapter)) || this;
      _this.tooltipShown = false;
      _this.anchorGap = numbers.BOUNDED_ANCHOR_GAP;
      _this.xTooltipPos = XPosition.DETECTED;
      _this.yTooltipPos = YPosition.DETECTED;
      _this.tooltipPositionWithCaret = PositionWithCaret.DETECTED;
      _this.minViewportTooltipThreshold = numbers.MIN_VIEWPORT_TOOLTIP_THRESHOLD;
      _this.hideDelayMs = numbers.HIDE_DELAY_MS;
      _this.showDelayMs = numbers.SHOW_DELAY_MS;
      _this.anchorRect = null;
      _this.parentRect = null;
      _this.frameId = null;
      _this.hideTimeout = null;
      _this.showTimeout = null;
      _this.addAncestorScrollEventListeners = new Array();
      _this.removeAncestorScrollEventListeners = new Array();
      _this.animFrame = new AnimationFrame();
      _this.anchorBlurHandler = function(evt) {
        _this.handleAnchorBlur(evt);
      };
      _this.documentClickHandler = function(evt) {
        _this.handleDocumentClick(evt);
      };
      _this.documentKeydownHandler = function(evt) {
        _this.handleKeydown(evt);
      };
      _this.tooltipMouseEnterHandler = function() {
        _this.handleTooltipMouseEnter();
      };
      _this.tooltipMouseLeaveHandler = function() {
        _this.handleTooltipMouseLeave();
      };
      _this.richTooltipFocusOutHandler = function(evt) {
        _this.handleRichTooltipFocusOut(evt);
      };
      _this.windowScrollHandler = function() {
        _this.handleWindowScrollEvent();
      };
      _this.windowResizeHandler = function() {
        _this.handleWindowChangeEvent();
      };
      return _this;
    }
    Object.defineProperty(MDCTooltipFoundation2, "defaultAdapter", {
      get: function() {
        return {
          getAttribute: function() {
            return null;
          },
          setAttribute: function() {
            return void 0;
          },
          removeAttribute: function() {
            return void 0;
          },
          addClass: function() {
            return void 0;
          },
          hasClass: function() {
            return false;
          },
          removeClass: function() {
            return void 0;
          },
          getComputedStyleProperty: function() {
            return "";
          },
          setStyleProperty: function() {
            return void 0;
          },
          setSurfaceAnimationStyleProperty: function() {
            return void 0;
          },
          getViewportWidth: function() {
            return 0;
          },
          getViewportHeight: function() {
            return 0;
          },
          getTooltipSize: function() {
            return { width: 0, height: 0 };
          },
          getAnchorBoundingRect: function() {
            return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
          },
          getParentBoundingRect: function() {
            return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
          },
          getAnchorAttribute: function() {
            return null;
          },
          setAnchorAttribute: function() {
            return null;
          },
          isRTL: function() {
            return false;
          },
          anchorContainsElement: function() {
            return false;
          },
          tooltipContainsElement: function() {
            return false;
          },
          focusAnchorElement: function() {
            return void 0;
          },
          registerEventHandler: function() {
            return void 0;
          },
          deregisterEventHandler: function() {
            return void 0;
          },
          registerAnchorEventHandler: function() {
            return void 0;
          },
          deregisterAnchorEventHandler: function() {
            return void 0;
          },
          registerDocumentEventHandler: function() {
            return void 0;
          },
          deregisterDocumentEventHandler: function() {
            return void 0;
          },
          registerWindowEventHandler: function() {
            return void 0;
          },
          deregisterWindowEventHandler: function() {
            return void 0;
          },
          notifyHidden: function() {
            return void 0;
          },
          getTooltipCaretBoundingRect: function() {
            return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
          },
          setTooltipCaretStyle: function() {
            return void 0;
          },
          clearTooltipCaretStyles: function() {
            return void 0;
          },
          getActiveElement: function() {
            return null;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCTooltipFoundation2.prototype.init = function() {
      this.richTooltip = this.adapter.hasClass(RICH);
      this.persistentTooltip = this.adapter.getAttribute(attributes.PERSISTENT) === "true";
      this.interactiveTooltip = !!this.adapter.getAnchorAttribute(attributes.ARIA_EXPANDED) && this.adapter.getAnchorAttribute(attributes.ARIA_HASPOPUP) === "dialog";
      this.hasCaret = this.richTooltip && this.adapter.getAttribute(attributes.HAS_CARET) === "true";
    };
    MDCTooltipFoundation2.prototype.isShown = function() {
      return this.tooltipShown;
    };
    MDCTooltipFoundation2.prototype.isRich = function() {
      return this.richTooltip;
    };
    MDCTooltipFoundation2.prototype.isPersistent = function() {
      return this.persistentTooltip;
    };
    MDCTooltipFoundation2.prototype.handleAnchorMouseEnter = function() {
      var _this = this;
      if (this.tooltipShown) {
        this.show();
      } else {
        this.clearHideTimeout();
        this.showTimeout = setTimeout(function() {
          _this.show();
        }, this.showDelayMs);
      }
    };
    MDCTooltipFoundation2.prototype.handleAnchorTouchstart = function() {
      var _this = this;
      this.showTimeout = setTimeout(function() {
        _this.show();
      }, this.showDelayMs);
      this.adapter.registerWindowEventHandler("contextmenu", this.preventContextMenuOnLongTouch);
    };
    MDCTooltipFoundation2.prototype.preventContextMenuOnLongTouch = function(evt) {
      evt.preventDefault();
    };
    MDCTooltipFoundation2.prototype.handleAnchorTouchend = function() {
      this.clearShowTimeout();
      if (!this.isShown()) {
        this.adapter.deregisterWindowEventHandler("contextmenu", this.preventContextMenuOnLongTouch);
      }
    };
    MDCTooltipFoundation2.prototype.handleAnchorFocus = function(evt) {
      var _this = this;
      var relatedTarget = evt.relatedTarget;
      var tooltipContainsRelatedTarget = relatedTarget instanceof HTMLElement && this.adapter.tooltipContainsElement(relatedTarget);
      if (tooltipContainsRelatedTarget) {
        return;
      }
      this.showTimeout = setTimeout(function() {
        _this.show();
      }, this.showDelayMs);
    };
    MDCTooltipFoundation2.prototype.handleAnchorMouseLeave = function() {
      var _this = this;
      this.clearShowTimeout();
      this.hideTimeout = setTimeout(function() {
        _this.hide();
      }, this.hideDelayMs);
    };
    MDCTooltipFoundation2.prototype.handleAnchorClick = function() {
      if (this.tooltipShown) {
        this.hide();
      } else {
        this.show();
      }
    };
    MDCTooltipFoundation2.prototype.handleDocumentClick = function(evt) {
      var anchorOrTooltipContainsTargetElement = evt.target instanceof HTMLElement && (this.adapter.anchorContainsElement(evt.target) || this.adapter.tooltipContainsElement(evt.target));
      if (this.richTooltip && this.persistentTooltip && anchorOrTooltipContainsTargetElement) {
        return;
      }
      this.hide();
    };
    MDCTooltipFoundation2.prototype.handleKeydown = function(evt) {
      var key = normalizeKey(evt);
      if (key === KEY.ESCAPE) {
        var activeElement = this.adapter.getActiveElement();
        var tooltipContainsActiveElement = activeElement instanceof HTMLElement && this.adapter.tooltipContainsElement(activeElement);
        if (tooltipContainsActiveElement) {
          this.adapter.focusAnchorElement();
        }
        this.hide();
      }
    };
    MDCTooltipFoundation2.prototype.handleAnchorBlur = function(evt) {
      if (this.richTooltip) {
        var tooltipContainsRelatedTargetElement = evt.relatedTarget instanceof HTMLElement && this.adapter.tooltipContainsElement(evt.relatedTarget);
        if (tooltipContainsRelatedTargetElement) {
          return;
        }
        if (evt.relatedTarget === null && this.interactiveTooltip) {
          return;
        }
      }
      this.hide();
    };
    MDCTooltipFoundation2.prototype.handleTooltipMouseEnter = function() {
      this.show();
    };
    MDCTooltipFoundation2.prototype.handleTooltipMouseLeave = function() {
      var _this = this;
      this.clearShowTimeout();
      this.hideTimeout = setTimeout(function() {
        _this.hide();
      }, this.hideDelayMs);
    };
    MDCTooltipFoundation2.prototype.handleRichTooltipFocusOut = function(evt) {
      var anchorOrTooltipContainsRelatedTargetElement = evt.relatedTarget instanceof HTMLElement && (this.adapter.anchorContainsElement(evt.relatedTarget) || this.adapter.tooltipContainsElement(evt.relatedTarget));
      if (anchorOrTooltipContainsRelatedTargetElement) {
        return;
      }
      if (evt.relatedTarget === null && this.interactiveTooltip) {
        return;
      }
      this.hide();
    };
    MDCTooltipFoundation2.prototype.handleWindowScrollEvent = function() {
      if (this.persistentTooltip) {
        this.handleWindowChangeEvent();
        return;
      }
      this.hide();
    };
    MDCTooltipFoundation2.prototype.handleWindowChangeEvent = function() {
      var _this = this;
      this.animFrame.request(AnimationKeys.POLL_ANCHOR, function() {
        _this.repositionTooltipOnAnchorMove();
      });
    };
    MDCTooltipFoundation2.prototype.show = function() {
      var e_1, _a;
      var _this = this;
      this.clearHideTimeout();
      this.clearShowTimeout();
      if (this.tooltipShown) {
        return;
      }
      this.tooltipShown = true;
      this.adapter.removeAttribute("aria-hidden");
      if (this.richTooltip) {
        if (this.interactiveTooltip) {
          this.adapter.setAnchorAttribute("aria-expanded", "true");
        }
        this.adapter.registerEventHandler("focusout", this.richTooltipFocusOutHandler);
      }
      if (!this.persistentTooltip) {
        this.adapter.registerEventHandler("mouseenter", this.tooltipMouseEnterHandler);
        this.adapter.registerEventHandler("mouseleave", this.tooltipMouseLeaveHandler);
      }
      this.adapter.removeClass(HIDE);
      this.adapter.addClass(SHOWING);
      if (this.isTooltipMultiline() && !this.richTooltip) {
        this.adapter.addClass(MULTILINE_TOOLTIP);
      }
      this.anchorRect = this.adapter.getAnchorBoundingRect();
      this.parentRect = this.adapter.getParentBoundingRect();
      this.richTooltip ? this.positionRichTooltip() : this.positionPlainTooltip();
      this.adapter.registerAnchorEventHandler("blur", this.anchorBlurHandler);
      this.adapter.registerDocumentEventHandler("click", this.documentClickHandler);
      this.adapter.registerDocumentEventHandler("keydown", this.documentKeydownHandler);
      this.adapter.registerWindowEventHandler("scroll", this.windowScrollHandler);
      this.adapter.registerWindowEventHandler("resize", this.windowResizeHandler);
      try {
        for (var _b = __values(this.addAncestorScrollEventListeners), _c = _b.next(); !_c.done; _c = _b.next()) {
          var fn = _c.value;
          fn();
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      this.frameId = requestAnimationFrame(function() {
        _this.clearAllAnimationClasses();
        _this.adapter.addClass(SHOWN);
        _this.adapter.addClass(SHOWING_TRANSITION);
      });
    };
    MDCTooltipFoundation2.prototype.hide = function() {
      var e_2, _a;
      this.clearHideTimeout();
      this.clearShowTimeout();
      if (!this.tooltipShown) {
        return;
      }
      if (this.frameId) {
        cancelAnimationFrame(this.frameId);
      }
      this.tooltipShown = false;
      this.adapter.setAttribute("aria-hidden", "true");
      this.adapter.deregisterEventHandler("focusout", this.richTooltipFocusOutHandler);
      if (this.richTooltip) {
        if (this.interactiveTooltip) {
          this.adapter.setAnchorAttribute("aria-expanded", "false");
        }
      }
      if (!this.persistentTooltip) {
        this.adapter.deregisterEventHandler("mouseenter", this.tooltipMouseEnterHandler);
        this.adapter.deregisterEventHandler("mouseleave", this.tooltipMouseLeaveHandler);
      }
      this.clearAllAnimationClasses();
      this.adapter.addClass(HIDE);
      this.adapter.addClass(HIDE_TRANSITION);
      this.adapter.removeClass(SHOWN);
      this.adapter.deregisterAnchorEventHandler("blur", this.anchorBlurHandler);
      this.adapter.deregisterDocumentEventHandler("click", this.documentClickHandler);
      this.adapter.deregisterDocumentEventHandler("keydown", this.documentKeydownHandler);
      this.adapter.deregisterWindowEventHandler("scroll", this.windowScrollHandler);
      this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
      this.adapter.deregisterWindowEventHandler("contextmenu", this.preventContextMenuOnLongTouch);
      try {
        for (var _b = __values(this.removeAncestorScrollEventListeners), _c = _b.next(); !_c.done; _c = _b.next()) {
          var fn = _c.value;
          fn();
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    };
    MDCTooltipFoundation2.prototype.handleTransitionEnd = function() {
      var isHidingTooltip = this.adapter.hasClass(HIDE);
      this.adapter.removeClass(SHOWING);
      this.adapter.removeClass(SHOWING_TRANSITION);
      this.adapter.removeClass(HIDE);
      this.adapter.removeClass(HIDE_TRANSITION);
      if (isHidingTooltip && this.showTimeout === null) {
        this.adapter.notifyHidden();
      }
    };
    MDCTooltipFoundation2.prototype.clearAllAnimationClasses = function() {
      this.adapter.removeClass(SHOWING_TRANSITION);
      this.adapter.removeClass(HIDE_TRANSITION);
    };
    MDCTooltipFoundation2.prototype.setTooltipPosition = function(position) {
      var xPos = position.xPos, yPos = position.yPos, withCaretPos = position.withCaretPos;
      if (this.hasCaret && withCaretPos) {
        this.tooltipPositionWithCaret = withCaretPos;
        return;
      }
      if (xPos) {
        this.xTooltipPos = xPos;
      }
      if (yPos) {
        this.yTooltipPos = yPos;
      }
    };
    MDCTooltipFoundation2.prototype.setAnchorBoundaryType = function(type) {
      if (type === AnchorBoundaryType.UNBOUNDED) {
        this.anchorGap = numbers.UNBOUNDED_ANCHOR_GAP;
      } else {
        this.anchorGap = numbers.BOUNDED_ANCHOR_GAP;
      }
    };
    MDCTooltipFoundation2.prototype.setShowDelay = function(delayMs) {
      this.showDelayMs = delayMs;
    };
    MDCTooltipFoundation2.prototype.setHideDelay = function(delayMs) {
      this.hideDelayMs = delayMs;
    };
    MDCTooltipFoundation2.prototype.isTooltipMultiline = function() {
      var tooltipSize = this.adapter.getTooltipSize();
      return tooltipSize.height > numbers.MIN_HEIGHT && tooltipSize.width >= numbers.MAX_WIDTH;
    };
    MDCTooltipFoundation2.prototype.positionPlainTooltip = function() {
      var _a = this.calculateTooltipStyles(this.anchorRect), top = _a.top, yTransformOrigin = _a.yTransformOrigin, left = _a.left, xTransformOrigin = _a.xTransformOrigin;
      var transformProperty = HAS_WINDOW ? getCorrectPropertyName(window, "transform") : "transform";
      this.adapter.setSurfaceAnimationStyleProperty(transformProperty + "-origin", xTransformOrigin + " " + yTransformOrigin);
      this.adapter.setStyleProperty("top", top + "px");
      this.adapter.setStyleProperty("left", left + "px");
    };
    MDCTooltipFoundation2.prototype.positionRichTooltip = function() {
      var _a, _b, _c, _d;
      var width = this.adapter.getComputedStyleProperty("width");
      this.adapter.setStyleProperty("width", width);
      var _e = this.hasCaret ? this.calculateTooltipWithCaretStyles(this.anchorRect) : this.calculateTooltipStyles(this.anchorRect), top = _e.top, yTransformOrigin = _e.yTransformOrigin, left = _e.left, xTransformOrigin = _e.xTransformOrigin;
      var transformProperty = HAS_WINDOW ? getCorrectPropertyName(window, "transform") : "transform";
      this.adapter.setSurfaceAnimationStyleProperty(transformProperty + "-origin", xTransformOrigin + " " + yTransformOrigin);
      var leftAdjustment = left - ((_b = (_a = this.parentRect) === null || _a === void 0 ? void 0 : _a.left) !== null && _b !== void 0 ? _b : 0);
      var topAdjustment = top - ((_d = (_c = this.parentRect) === null || _c === void 0 ? void 0 : _c.top) !== null && _d !== void 0 ? _d : 0);
      this.adapter.setStyleProperty("top", topAdjustment + "px");
      this.adapter.setStyleProperty("left", leftAdjustment + "px");
    };
    MDCTooltipFoundation2.prototype.calculateTooltipStyles = function(anchorRect) {
      if (!anchorRect) {
        return { top: 0, left: 0 };
      }
      var tooltipSize = this.adapter.getTooltipSize();
      var top = this.calculateYTooltipDistance(anchorRect, tooltipSize.height);
      var left = this.calculateXTooltipDistance(anchorRect, tooltipSize.width);
      return {
        top: top.distance,
        yTransformOrigin: top.yTransformOrigin,
        left: left.distance,
        xTransformOrigin: left.xTransformOrigin
      };
    };
    MDCTooltipFoundation2.prototype.calculateXTooltipDistance = function(anchorRect, tooltipWidth) {
      var isLTR = !this.adapter.isRTL();
      var startPos, endPos, centerPos;
      var startTransformOrigin, endTransformOrigin;
      if (this.richTooltip) {
        startPos = isLTR ? anchorRect.left - tooltipWidth : anchorRect.right;
        endPos = isLTR ? anchorRect.right : anchorRect.left - tooltipWidth;
        startTransformOrigin = isLTR ? strings.RIGHT : strings.LEFT;
        endTransformOrigin = isLTR ? strings.LEFT : strings.RIGHT;
      } else {
        startPos = isLTR ? anchorRect.left : anchorRect.right - tooltipWidth;
        endPos = isLTR ? anchorRect.right - tooltipWidth : anchorRect.left;
        centerPos = anchorRect.left + (anchorRect.width - tooltipWidth) / 2;
        startTransformOrigin = isLTR ? strings.LEFT : strings.RIGHT;
        endTransformOrigin = isLTR ? strings.RIGHT : strings.LEFT;
      }
      var positionOptions = this.richTooltip ? this.determineValidPositionOptions(startPos, endPos) : (
        // For plain tooltips, centerPos is defined
        this.determineValidPositionOptions(centerPos, startPos, endPos)
      );
      if (this.xTooltipPos === XPosition.START && positionOptions.has(startPos)) {
        return { distance: startPos, xTransformOrigin: startTransformOrigin };
      }
      if (this.xTooltipPos === XPosition.END && positionOptions.has(endPos)) {
        return { distance: endPos, xTransformOrigin: endTransformOrigin };
      }
      if (this.xTooltipPos === XPosition.CENTER && positionOptions.has(centerPos)) {
        return { distance: centerPos, xTransformOrigin: strings.CENTER };
      }
      var possiblePositions = this.richTooltip ? [
        { distance: endPos, xTransformOrigin: endTransformOrigin },
        { distance: startPos, xTransformOrigin: startTransformOrigin }
      ] : [
        { distance: centerPos, xTransformOrigin: strings.CENTER },
        { distance: startPos, xTransformOrigin: startTransformOrigin },
        { distance: endPos, xTransformOrigin: endTransformOrigin }
      ];
      var validPosition = possiblePositions.find(function(_a) {
        var distance2 = _a.distance;
        return positionOptions.has(distance2);
      });
      if (validPosition) {
        return validPosition;
      }
      if (anchorRect.left < 0) {
        return {
          distance: this.minViewportTooltipThreshold,
          xTransformOrigin: strings.LEFT
        };
      } else {
        var viewportWidth = this.adapter.getViewportWidth();
        var distance = viewportWidth - (tooltipWidth + this.minViewportTooltipThreshold);
        return { distance, xTransformOrigin: strings.RIGHT };
      }
    };
    MDCTooltipFoundation2.prototype.determineValidPositionOptions = function() {
      var e_3, _a;
      var positions = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        positions[_i] = arguments[_i];
      }
      var posWithinThreshold = /* @__PURE__ */ new Set();
      var posWithinViewport = /* @__PURE__ */ new Set();
      try {
        for (var positions_1 = __values(positions), positions_1_1 = positions_1.next(); !positions_1_1.done; positions_1_1 = positions_1.next()) {
          var position = positions_1_1.value;
          if (this.positionHonorsViewportThreshold(position)) {
            posWithinThreshold.add(position);
          } else if (this.positionDoesntCollideWithViewport(position)) {
            posWithinViewport.add(position);
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (positions_1_1 && !positions_1_1.done && (_a = positions_1.return))
            _a.call(positions_1);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      return posWithinThreshold.size ? posWithinThreshold : posWithinViewport;
    };
    MDCTooltipFoundation2.prototype.positionHonorsViewportThreshold = function(leftPos) {
      var viewportWidth = this.adapter.getViewportWidth();
      var tooltipWidth = this.adapter.getTooltipSize().width;
      return leftPos + tooltipWidth <= viewportWidth - this.minViewportTooltipThreshold && leftPos >= this.minViewportTooltipThreshold;
    };
    MDCTooltipFoundation2.prototype.positionDoesntCollideWithViewport = function(leftPos) {
      var viewportWidth = this.adapter.getViewportWidth();
      var tooltipWidth = this.adapter.getTooltipSize().width;
      return leftPos + tooltipWidth <= viewportWidth && leftPos >= 0;
    };
    MDCTooltipFoundation2.prototype.calculateYTooltipDistance = function(anchorRect, tooltipHeight) {
      var belowYPos = anchorRect.bottom + this.anchorGap;
      var aboveYPos = anchorRect.top - (this.anchorGap + tooltipHeight);
      var yPositionOptions = this.determineValidYPositionOptions(aboveYPos, belowYPos);
      if (this.yTooltipPos === YPosition.ABOVE && yPositionOptions.has(aboveYPos)) {
        return { distance: aboveYPos, yTransformOrigin: strings.BOTTOM };
      } else if (this.yTooltipPos === YPosition.BELOW && yPositionOptions.has(belowYPos)) {
        return { distance: belowYPos, yTransformOrigin: strings.TOP };
      }
      if (yPositionOptions.has(belowYPos)) {
        return { distance: belowYPos, yTransformOrigin: strings.TOP };
      }
      if (yPositionOptions.has(aboveYPos)) {
        return { distance: aboveYPos, yTransformOrigin: strings.BOTTOM };
      }
      return { distance: belowYPos, yTransformOrigin: strings.TOP };
    };
    MDCTooltipFoundation2.prototype.determineValidYPositionOptions = function(aboveAnchorPos, belowAnchorPos) {
      var posWithinThreshold = /* @__PURE__ */ new Set();
      var posWithinViewport = /* @__PURE__ */ new Set();
      if (this.yPositionHonorsViewportThreshold(aboveAnchorPos)) {
        posWithinThreshold.add(aboveAnchorPos);
      } else if (this.yPositionDoesntCollideWithViewport(aboveAnchorPos)) {
        posWithinViewport.add(aboveAnchorPos);
      }
      if (this.yPositionHonorsViewportThreshold(belowAnchorPos)) {
        posWithinThreshold.add(belowAnchorPos);
      } else if (this.yPositionDoesntCollideWithViewport(belowAnchorPos)) {
        posWithinViewport.add(belowAnchorPos);
      }
      return posWithinThreshold.size ? posWithinThreshold : posWithinViewport;
    };
    MDCTooltipFoundation2.prototype.yPositionHonorsViewportThreshold = function(yPos) {
      var viewportHeight = this.adapter.getViewportHeight();
      var tooltipHeight = this.adapter.getTooltipSize().height;
      return yPos + tooltipHeight + this.minViewportTooltipThreshold <= viewportHeight && yPos >= this.minViewportTooltipThreshold;
    };
    MDCTooltipFoundation2.prototype.yPositionDoesntCollideWithViewport = function(yPos) {
      var viewportHeight = this.adapter.getViewportHeight();
      var tooltipHeight = this.adapter.getTooltipSize().height;
      return yPos + tooltipHeight <= viewportHeight && yPos >= 0;
    };
    MDCTooltipFoundation2.prototype.calculateTooltipWithCaretStyles = function(anchorRect) {
      this.adapter.clearTooltipCaretStyles();
      var caretSize = this.adapter.getTooltipCaretBoundingRect();
      if (!anchorRect || !caretSize) {
        return { position: PositionWithCaret.DETECTED, top: 0, left: 0 };
      }
      var caretWidth = caretSize.width / numbers.ANIMATION_SCALE;
      var caretHeight = caretSize.height / numbers.ANIMATION_SCALE / 2;
      var tooltipSize = this.adapter.getTooltipSize();
      var yOptions = this.calculateYWithCaretDistanceOptions(anchorRect, tooltipSize.height, { caretWidth, caretHeight });
      var xOptions = this.calculateXWithCaretDistanceOptions(anchorRect, tooltipSize.width, { caretWidth, caretHeight });
      var positionOptions = this.validateTooltipWithCaretDistances(yOptions, xOptions);
      if (positionOptions.size < 1) {
        positionOptions = this.generateBackupPositionOption(anchorRect, tooltipSize, { caretWidth, caretHeight });
      }
      var _a = this.determineTooltipWithCaretDistance(positionOptions), position = _a.position, xDistance = _a.xDistance, yDistance = _a.yDistance;
      var _b = this.setCaretPositionStyles(position, { caretWidth, caretHeight }), yTransformOrigin = _b.yTransformOrigin, xTransformOrigin = _b.xTransformOrigin;
      return {
        yTransformOrigin,
        xTransformOrigin,
        top: yDistance,
        left: xDistance
      };
    };
    MDCTooltipFoundation2.prototype.calculateXWithCaretDistanceOptions = function(anchorRect, tooltipWidth, caretSize) {
      var caretWidth = caretSize.caretWidth, caretHeight = caretSize.caretHeight;
      var isLTR = !this.adapter.isRTL();
      var anchorMidpoint = anchorRect.left + anchorRect.width / 2;
      var sideLeftAligned = anchorRect.left - (tooltipWidth + this.anchorGap + caretHeight);
      var sideRightAligned = anchorRect.right + this.anchorGap + caretHeight;
      var sideStartPos = isLTR ? sideLeftAligned : sideRightAligned;
      var sideEndPos = isLTR ? sideRightAligned : sideLeftAligned;
      var verticalLeftAligned = anchorMidpoint - (numbers.CARET_INDENTATION + caretWidth / 2);
      var verticalRightAligned = anchorMidpoint - (tooltipWidth - numbers.CARET_INDENTATION - caretWidth / 2);
      var verticalStartPos = isLTR ? verticalLeftAligned : verticalRightAligned;
      var verticalEndPos = isLTR ? verticalRightAligned : verticalLeftAligned;
      var verticalCenterPos = anchorMidpoint - tooltipWidth / 2;
      var possiblePositionsMap = /* @__PURE__ */ new Map([
        [XPositionWithCaret.START, verticalStartPos],
        [XPositionWithCaret.CENTER, verticalCenterPos],
        [XPositionWithCaret.END, verticalEndPos],
        [XPositionWithCaret.SIDE_END, sideEndPos],
        [XPositionWithCaret.SIDE_START, sideStartPos]
      ]);
      return possiblePositionsMap;
    };
    MDCTooltipFoundation2.prototype.calculateYWithCaretDistanceOptions = function(anchorRect, tooltipHeight, caretSize) {
      var caretWidth = caretSize.caretWidth, caretHeight = caretSize.caretHeight;
      var anchorMidpoint = anchorRect.top + anchorRect.height / 2;
      var belowYPos = anchorRect.bottom + this.anchorGap + caretHeight;
      var aboveYPos = anchorRect.top - (this.anchorGap + tooltipHeight + caretHeight);
      var sideTopYPos = anchorMidpoint - (numbers.CARET_INDENTATION + caretWidth / 2);
      var sideCenterYPos = anchorMidpoint - tooltipHeight / 2;
      var sideBottomYPos = anchorMidpoint - (tooltipHeight - numbers.CARET_INDENTATION - caretWidth / 2);
      var possiblePositionsMap = /* @__PURE__ */ new Map([
        [YPositionWithCaret.ABOVE, aboveYPos],
        [YPositionWithCaret.BELOW, belowYPos],
        [YPositionWithCaret.SIDE_TOP, sideTopYPos],
        [YPositionWithCaret.SIDE_CENTER, sideCenterYPos],
        [YPositionWithCaret.SIDE_BOTTOM, sideBottomYPos]
      ]);
      return possiblePositionsMap;
    };
    MDCTooltipFoundation2.prototype.repositionTooltipOnAnchorMove = function() {
      var newAnchorRect = this.adapter.getAnchorBoundingRect();
      if (!newAnchorRect || !this.anchorRect)
        return;
      if (newAnchorRect.top !== this.anchorRect.top || newAnchorRect.left !== this.anchorRect.left || newAnchorRect.height !== this.anchorRect.height || newAnchorRect.width !== this.anchorRect.width) {
        this.anchorRect = newAnchorRect;
        this.parentRect = this.adapter.getParentBoundingRect();
        this.richTooltip ? this.positionRichTooltip() : this.positionPlainTooltip();
      }
    };
    MDCTooltipFoundation2.prototype.validateTooltipWithCaretDistances = function(yOptions, xOptions) {
      var e_4, _a, e_5, _b, e_6, _c;
      var posWithinThreshold = /* @__PURE__ */ new Map();
      var posWithinViewport = /* @__PURE__ */ new Map();
      var validMappings = /* @__PURE__ */ new Map([
        [
          YPositionWithCaret.ABOVE,
          [
            XPositionWithCaret.START,
            XPositionWithCaret.CENTER,
            XPositionWithCaret.END
          ]
        ],
        [
          YPositionWithCaret.BELOW,
          [
            XPositionWithCaret.START,
            XPositionWithCaret.CENTER,
            XPositionWithCaret.END
          ]
        ],
        [
          YPositionWithCaret.SIDE_TOP,
          [XPositionWithCaret.SIDE_START, XPositionWithCaret.SIDE_END]
        ],
        [
          YPositionWithCaret.SIDE_CENTER,
          [XPositionWithCaret.SIDE_START, XPositionWithCaret.SIDE_END]
        ],
        [
          YPositionWithCaret.SIDE_BOTTOM,
          [XPositionWithCaret.SIDE_START, XPositionWithCaret.SIDE_END]
        ]
      ]);
      try {
        for (var _d = __values(validMappings.keys()), _e = _d.next(); !_e.done; _e = _d.next()) {
          var y = _e.value;
          var yDistance = yOptions.get(y);
          if (this.yPositionHonorsViewportThreshold(yDistance)) {
            try {
              for (var _f = (e_5 = void 0, __values(validMappings.get(y))), _g = _f.next(); !_g.done; _g = _f.next()) {
                var x = _g.value;
                var xDistance = xOptions.get(x);
                if (this.positionHonorsViewportThreshold(xDistance)) {
                  var caretPositionName = this.caretPositionOptionsMapping(x, y);
                  posWithinThreshold.set(caretPositionName, { xDistance, yDistance });
                }
              }
            } catch (e_5_1) {
              e_5 = { error: e_5_1 };
            } finally {
              try {
                if (_g && !_g.done && (_b = _f.return))
                  _b.call(_f);
              } finally {
                if (e_5)
                  throw e_5.error;
              }
            }
          }
          if (this.yPositionDoesntCollideWithViewport(yDistance)) {
            try {
              for (var _h = (e_6 = void 0, __values(validMappings.get(y))), _j = _h.next(); !_j.done; _j = _h.next()) {
                var x = _j.value;
                var xDistance = xOptions.get(x);
                if (this.positionDoesntCollideWithViewport(xDistance)) {
                  var caretPositionName = this.caretPositionOptionsMapping(x, y);
                  posWithinViewport.set(caretPositionName, { xDistance, yDistance });
                }
              }
            } catch (e_6_1) {
              e_6 = { error: e_6_1 };
            } finally {
              try {
                if (_j && !_j.done && (_c = _h.return))
                  _c.call(_h);
              } finally {
                if (e_6)
                  throw e_6.error;
              }
            }
          }
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (_e && !_e.done && (_a = _d.return))
            _a.call(_d);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
      return posWithinThreshold.size ? posWithinThreshold : posWithinViewport;
    };
    MDCTooltipFoundation2.prototype.generateBackupPositionOption = function(anchorRect, tooltipSize, caretSize) {
      var isLTR = !this.adapter.isRTL();
      var xDistance;
      var xPos;
      if (anchorRect.left < 0) {
        xDistance = this.minViewportTooltipThreshold + caretSize.caretHeight;
        xPos = isLTR ? XPositionWithCaret.END : XPositionWithCaret.START;
      } else {
        var viewportWidth = this.adapter.getViewportWidth();
        xDistance = viewportWidth - (tooltipSize.width + this.minViewportTooltipThreshold + caretSize.caretHeight);
        xPos = isLTR ? XPositionWithCaret.START : XPositionWithCaret.END;
      }
      var yDistance;
      var yPos;
      if (anchorRect.top < 0) {
        yDistance = this.minViewportTooltipThreshold + caretSize.caretHeight;
        yPos = YPositionWithCaret.BELOW;
      } else {
        var viewportHeight = this.adapter.getViewportHeight();
        yDistance = viewportHeight - (tooltipSize.height + this.minViewportTooltipThreshold + caretSize.caretHeight);
        yPos = YPositionWithCaret.ABOVE;
      }
      var caretPositionName = this.caretPositionOptionsMapping(xPos, yPos);
      return /* @__PURE__ */ new Map([[caretPositionName, { xDistance, yDistance }]]);
    };
    MDCTooltipFoundation2.prototype.determineTooltipWithCaretDistance = function(options) {
      if (options.has(this.tooltipPositionWithCaret)) {
        var tooltipPos = options.get(this.tooltipPositionWithCaret);
        return {
          position: this.tooltipPositionWithCaret,
          xDistance: tooltipPos.xDistance,
          yDistance: tooltipPos.yDistance
        };
      }
      var orderPref = [
        PositionWithCaret.ABOVE_START,
        PositionWithCaret.ABOVE_CENTER,
        PositionWithCaret.ABOVE_END,
        PositionWithCaret.TOP_SIDE_START,
        PositionWithCaret.CENTER_SIDE_START,
        PositionWithCaret.BOTTOM_SIDE_START,
        PositionWithCaret.TOP_SIDE_END,
        PositionWithCaret.CENTER_SIDE_END,
        PositionWithCaret.BOTTOM_SIDE_END,
        PositionWithCaret.BELOW_START,
        PositionWithCaret.BELOW_CENTER,
        PositionWithCaret.BELOW_END
      ];
      var validPosition = orderPref.find(function(pos2) {
        return options.has(pos2);
      });
      var pos = options.get(validPosition);
      return {
        position: validPosition,
        xDistance: pos.xDistance,
        yDistance: pos.yDistance
      };
    };
    MDCTooltipFoundation2.prototype.caretPositionOptionsMapping = function(xPos, yPos) {
      switch (yPos) {
        case YPositionWithCaret.ABOVE:
          if (xPos === XPositionWithCaret.START) {
            return PositionWithCaret.ABOVE_START;
          } else if (xPos === XPositionWithCaret.CENTER) {
            return PositionWithCaret.ABOVE_CENTER;
          } else if (xPos === XPositionWithCaret.END) {
            return PositionWithCaret.ABOVE_END;
          }
          break;
        case YPositionWithCaret.BELOW:
          if (xPos === XPositionWithCaret.START) {
            return PositionWithCaret.BELOW_START;
          } else if (xPos === XPositionWithCaret.CENTER) {
            return PositionWithCaret.BELOW_CENTER;
          } else if (xPos === XPositionWithCaret.END) {
            return PositionWithCaret.BELOW_END;
          }
          break;
        case YPositionWithCaret.SIDE_TOP:
          if (xPos === XPositionWithCaret.SIDE_START) {
            return PositionWithCaret.TOP_SIDE_START;
          } else if (xPos === XPositionWithCaret.SIDE_END) {
            return PositionWithCaret.TOP_SIDE_END;
          }
          break;
        case YPositionWithCaret.SIDE_CENTER:
          if (xPos === XPositionWithCaret.SIDE_START) {
            return PositionWithCaret.CENTER_SIDE_START;
          } else if (xPos === XPositionWithCaret.SIDE_END) {
            return PositionWithCaret.CENTER_SIDE_END;
          }
          break;
        case YPositionWithCaret.SIDE_BOTTOM:
          if (xPos === XPositionWithCaret.SIDE_START) {
            return PositionWithCaret.BOTTOM_SIDE_START;
          } else if (xPos === XPositionWithCaret.SIDE_END) {
            return PositionWithCaret.BOTTOM_SIDE_END;
          }
          break;
        default:
          break;
      }
      throw new Error("MDCTooltipFoundation: Invalid caret position of " + xPos + ", " + yPos);
    };
    MDCTooltipFoundation2.prototype.setCaretPositionStyles = function(position, caretSize) {
      var e_7, _a;
      var values = this.calculateCaretPositionOnTooltip(position, caretSize);
      if (!values) {
        return { yTransformOrigin: 0, xTransformOrigin: 0 };
      }
      this.adapter.clearTooltipCaretStyles();
      this.adapter.setTooltipCaretStyle(values.yAlignment, values.yAxisPx);
      this.adapter.setTooltipCaretStyle(values.xAlignment, values.xAxisPx);
      var skewRadians = values.skew * (Math.PI / 180);
      var scaleX = Math.cos(skewRadians);
      this.adapter.setTooltipCaretStyle("transform", "rotate(" + values.rotation + "deg) skewY(" + values.skew + "deg) scaleX(" + scaleX + ")");
      this.adapter.setTooltipCaretStyle("transform-origin", values.xAlignment + " " + values.yAlignment);
      try {
        for (var _b = __values(values.caretCorners), _c = _b.next(); !_c.done; _c = _b.next()) {
          var corner = _c.value;
          this.adapter.setTooltipCaretStyle(corner, "0");
        }
      } catch (e_7_1) {
        e_7 = { error: e_7_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_7)
            throw e_7.error;
        }
      }
      return {
        yTransformOrigin: values.yTransformOrigin,
        xTransformOrigin: values.xTransformOrigin
      };
    };
    MDCTooltipFoundation2.prototype.calculateCaretPositionOnTooltip = function(tooltipPos, caretSize) {
      var isLTR = !this.adapter.isRTL();
      var tooltipWidth = this.adapter.getComputedStyleProperty("width");
      var tooltipHeight = this.adapter.getComputedStyleProperty("height");
      if (!tooltipWidth || !tooltipHeight || !caretSize) {
        return;
      }
      var midpointWidth = "calc((" + tooltipWidth + " - " + caretSize.caretWidth + "px) / 2)";
      var midpointHeight = "calc((" + tooltipHeight + " - " + caretSize.caretWidth + "px) / 2)";
      var flushWithEdge = "0";
      var indentedFromEdge = numbers.CARET_INDENTATION + "px";
      var indentedFromWidth = "calc(" + tooltipWidth + " - " + indentedFromEdge + ")";
      var indentedFromHeight = "calc(" + tooltipHeight + " - " + indentedFromEdge + ")";
      var verticalRotation = 35;
      var horizontalRotation = Math.abs(90 - verticalRotation);
      var bottomRightTopLeftBorderRadius = ["border-bottom-right-radius", "border-top-left-radius"];
      var bottomLeftTopRightBorderRadius = ["border-bottom-left-radius", "border-top-right-radius"];
      var skewDeg = 20;
      switch (tooltipPos) {
        case PositionWithCaret.BELOW_CENTER:
          return {
            yAlignment: strings.TOP,
            xAlignment: strings.LEFT,
            yAxisPx: flushWithEdge,
            xAxisPx: midpointWidth,
            rotation: -1 * verticalRotation,
            skew: -1 * skewDeg,
            xTransformOrigin: midpointWidth,
            yTransformOrigin: flushWithEdge,
            caretCorners: bottomRightTopLeftBorderRadius
          };
        case PositionWithCaret.BELOW_END:
          return {
            yAlignment: strings.TOP,
            xAlignment: isLTR ? strings.RIGHT : strings.LEFT,
            yAxisPx: flushWithEdge,
            xAxisPx: indentedFromEdge,
            rotation: isLTR ? verticalRotation : -1 * verticalRotation,
            skew: isLTR ? skewDeg : -1 * skewDeg,
            xTransformOrigin: isLTR ? indentedFromWidth : indentedFromEdge,
            yTransformOrigin: flushWithEdge,
            caretCorners: isLTR ? bottomLeftTopRightBorderRadius : bottomRightTopLeftBorderRadius
          };
        case PositionWithCaret.BELOW_START:
          return {
            yAlignment: strings.TOP,
            xAlignment: isLTR ? strings.LEFT : strings.RIGHT,
            yAxisPx: flushWithEdge,
            xAxisPx: indentedFromEdge,
            rotation: isLTR ? -1 * verticalRotation : verticalRotation,
            skew: isLTR ? -1 * skewDeg : skewDeg,
            xTransformOrigin: isLTR ? indentedFromEdge : indentedFromWidth,
            yTransformOrigin: flushWithEdge,
            caretCorners: isLTR ? bottomRightTopLeftBorderRadius : bottomLeftTopRightBorderRadius
          };
        case PositionWithCaret.TOP_SIDE_END:
          return {
            yAlignment: strings.TOP,
            xAlignment: isLTR ? strings.LEFT : strings.RIGHT,
            yAxisPx: indentedFromEdge,
            xAxisPx: flushWithEdge,
            rotation: isLTR ? horizontalRotation : -1 * horizontalRotation,
            skew: isLTR ? -1 * skewDeg : skewDeg,
            xTransformOrigin: isLTR ? flushWithEdge : tooltipWidth,
            yTransformOrigin: indentedFromEdge,
            caretCorners: isLTR ? bottomRightTopLeftBorderRadius : bottomLeftTopRightBorderRadius
          };
        case PositionWithCaret.CENTER_SIDE_END:
          return {
            yAlignment: strings.TOP,
            xAlignment: isLTR ? strings.LEFT : strings.RIGHT,
            yAxisPx: midpointHeight,
            xAxisPx: flushWithEdge,
            rotation: isLTR ? horizontalRotation : -1 * horizontalRotation,
            skew: isLTR ? -1 * skewDeg : skewDeg,
            xTransformOrigin: isLTR ? flushWithEdge : tooltipWidth,
            yTransformOrigin: midpointHeight,
            caretCorners: isLTR ? bottomRightTopLeftBorderRadius : bottomLeftTopRightBorderRadius
          };
        case PositionWithCaret.BOTTOM_SIDE_END:
          return {
            yAlignment: strings.BOTTOM,
            xAlignment: isLTR ? strings.LEFT : strings.RIGHT,
            yAxisPx: indentedFromEdge,
            xAxisPx: flushWithEdge,
            rotation: isLTR ? -1 * horizontalRotation : horizontalRotation,
            skew: isLTR ? skewDeg : -1 * skewDeg,
            xTransformOrigin: isLTR ? flushWithEdge : tooltipWidth,
            yTransformOrigin: indentedFromHeight,
            caretCorners: isLTR ? bottomLeftTopRightBorderRadius : bottomRightTopLeftBorderRadius
          };
        case PositionWithCaret.TOP_SIDE_START:
          return {
            yAlignment: strings.TOP,
            xAlignment: isLTR ? strings.RIGHT : strings.LEFT,
            yAxisPx: indentedFromEdge,
            xAxisPx: flushWithEdge,
            rotation: isLTR ? -1 * horizontalRotation : horizontalRotation,
            skew: isLTR ? skewDeg : -1 * skewDeg,
            xTransformOrigin: isLTR ? tooltipWidth : flushWithEdge,
            yTransformOrigin: indentedFromEdge,
            caretCorners: isLTR ? bottomLeftTopRightBorderRadius : bottomRightTopLeftBorderRadius
          };
        case PositionWithCaret.CENTER_SIDE_START:
          return {
            yAlignment: strings.TOP,
            xAlignment: isLTR ? strings.RIGHT : strings.LEFT,
            yAxisPx: midpointHeight,
            xAxisPx: flushWithEdge,
            rotation: isLTR ? -1 * horizontalRotation : horizontalRotation,
            skew: isLTR ? skewDeg : -1 * skewDeg,
            xTransformOrigin: isLTR ? tooltipWidth : flushWithEdge,
            yTransformOrigin: midpointHeight,
            caretCorners: isLTR ? bottomLeftTopRightBorderRadius : bottomRightTopLeftBorderRadius
          };
        case PositionWithCaret.BOTTOM_SIDE_START:
          return {
            yAlignment: strings.BOTTOM,
            xAlignment: isLTR ? strings.RIGHT : strings.LEFT,
            yAxisPx: indentedFromEdge,
            xAxisPx: flushWithEdge,
            rotation: isLTR ? horizontalRotation : -1 * horizontalRotation,
            skew: isLTR ? -1 * skewDeg : skewDeg,
            xTransformOrigin: isLTR ? tooltipWidth : flushWithEdge,
            yTransformOrigin: indentedFromHeight,
            caretCorners: isLTR ? bottomRightTopLeftBorderRadius : bottomLeftTopRightBorderRadius
          };
        case PositionWithCaret.ABOVE_CENTER:
          return {
            yAlignment: strings.BOTTOM,
            xAlignment: strings.LEFT,
            yAxisPx: flushWithEdge,
            xAxisPx: midpointWidth,
            rotation: verticalRotation,
            skew: skewDeg,
            xTransformOrigin: midpointWidth,
            yTransformOrigin: tooltipHeight,
            caretCorners: bottomLeftTopRightBorderRadius
          };
        case PositionWithCaret.ABOVE_END:
          return {
            yAlignment: strings.BOTTOM,
            xAlignment: isLTR ? strings.RIGHT : strings.LEFT,
            yAxisPx: flushWithEdge,
            xAxisPx: indentedFromEdge,
            rotation: isLTR ? -1 * verticalRotation : verticalRotation,
            skew: isLTR ? -1 * skewDeg : skewDeg,
            xTransformOrigin: isLTR ? indentedFromWidth : indentedFromEdge,
            yTransformOrigin: tooltipHeight,
            caretCorners: isLTR ? bottomRightTopLeftBorderRadius : bottomLeftTopRightBorderRadius
          };
        default:
        case PositionWithCaret.ABOVE_START:
          return {
            yAlignment: strings.BOTTOM,
            xAlignment: isLTR ? strings.LEFT : strings.RIGHT,
            yAxisPx: flushWithEdge,
            xAxisPx: indentedFromEdge,
            rotation: isLTR ? verticalRotation : -1 * verticalRotation,
            skew: isLTR ? skewDeg : -1 * skewDeg,
            xTransformOrigin: isLTR ? indentedFromEdge : indentedFromWidth,
            yTransformOrigin: tooltipHeight,
            caretCorners: isLTR ? bottomLeftTopRightBorderRadius : bottomRightTopLeftBorderRadius
          };
      }
    };
    MDCTooltipFoundation2.prototype.clearShowTimeout = function() {
      if (this.showTimeout) {
        clearTimeout(this.showTimeout);
        this.showTimeout = null;
      }
    };
    MDCTooltipFoundation2.prototype.clearHideTimeout = function() {
      if (this.hideTimeout) {
        clearTimeout(this.hideTimeout);
        this.hideTimeout = null;
      }
    };
    MDCTooltipFoundation2.prototype.attachScrollHandler = function(addEventListenerFn) {
      var _this = this;
      this.addAncestorScrollEventListeners.push(function() {
        addEventListenerFn("scroll", _this.windowScrollHandler);
      });
    };
    MDCTooltipFoundation2.prototype.removeScrollHandler = function(removeEventHandlerFn) {
      var _this = this;
      this.removeAncestorScrollEventListeners.push(function() {
        removeEventHandlerFn("scroll", _this.windowScrollHandler);
      });
    };
    MDCTooltipFoundation2.prototype.destroy = function() {
      var e_8, _a;
      if (this.frameId) {
        cancelAnimationFrame(this.frameId);
        this.frameId = null;
      }
      this.clearHideTimeout();
      this.clearShowTimeout();
      this.adapter.removeClass(SHOWN);
      this.adapter.removeClass(SHOWING_TRANSITION);
      this.adapter.removeClass(SHOWING);
      this.adapter.removeClass(HIDE);
      this.adapter.removeClass(HIDE_TRANSITION);
      if (this.richTooltip) {
        this.adapter.deregisterEventHandler("focusout", this.richTooltipFocusOutHandler);
      }
      if (!this.persistentTooltip) {
        this.adapter.deregisterEventHandler("mouseenter", this.tooltipMouseEnterHandler);
        this.adapter.deregisterEventHandler("mouseleave", this.tooltipMouseLeaveHandler);
      }
      this.adapter.deregisterAnchorEventHandler("blur", this.anchorBlurHandler);
      this.adapter.deregisterDocumentEventHandler("click", this.documentClickHandler);
      this.adapter.deregisterDocumentEventHandler("keydown", this.documentKeydownHandler);
      this.adapter.deregisterWindowEventHandler("scroll", this.windowScrollHandler);
      this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
      try {
        for (var _b = __values(this.removeAncestorScrollEventListeners), _c = _b.next(); !_c.done; _c = _b.next()) {
          var fn = _c.value;
          fn();
        }
      } catch (e_8_1) {
        e_8 = { error: e_8_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_8)
            throw e_8.error;
        }
      }
      this.animFrame.cancelAll();
    };
    return MDCTooltipFoundation2;
  }(MDCFoundation)
);

// node_modules/@material/tooltip/component.js
var MDCTooltip = (
  /** @class */
  function(_super) {
    __extends(MDCTooltip2, _super);
    function MDCTooltip2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTooltip2.attachTo = function(root) {
      return new MDCTooltip2(root);
    };
    MDCTooltip2.prototype.initialize = function() {
      var tooltipId = this.root.getAttribute("id");
      if (!tooltipId) {
        throw new Error("MDCTooltip: Tooltip component must have an id.");
      }
      var anchorElem = document.querySelector('[data-tooltip-id="' + tooltipId + '"]') || document.querySelector('[aria-describedby="' + tooltipId + '"]');
      if (!anchorElem) {
        throw new Error("MDCTooltip: Tooltip component requires an anchor element annotated with [aria-describedby] or [data-tooltip-id].");
      }
      this.anchorElem = anchorElem;
    };
    MDCTooltip2.prototype.initialSyncWithDOM = function() {
      var _this = this;
      this.isTooltipRich = this.foundation.isRich();
      this.isTooltipPersistent = this.foundation.isPersistent();
      this.handleMouseEnter = function() {
        _this.foundation.handleAnchorMouseEnter();
      };
      this.handleFocus = function(evt) {
        _this.foundation.handleAnchorFocus(evt);
      };
      this.handleMouseLeave = function() {
        _this.foundation.handleAnchorMouseLeave();
      };
      this.handleTransitionEnd = function() {
        _this.foundation.handleTransitionEnd();
      };
      this.handleClick = function() {
        _this.foundation.handleAnchorClick();
      };
      this.handleTouchstart = function() {
        _this.foundation.handleAnchorTouchstart();
      };
      this.handleTouchend = function() {
        _this.foundation.handleAnchorTouchend();
      };
      if (this.isTooltipRich && this.isTooltipPersistent) {
        this.anchorElem.addEventListener("click", this.handleClick);
      } else {
        this.anchorElem.addEventListener("mouseenter", this.handleMouseEnter);
        this.anchorElem.addEventListener("focus", this.handleFocus);
        this.anchorElem.addEventListener("mouseleave", this.handleMouseLeave);
        this.anchorElem.addEventListener("touchstart", this.handleTouchstart);
        this.anchorElem.addEventListener("touchend", this.handleTouchend);
      }
      this.listen("transitionend", this.handleTransitionEnd);
    };
    MDCTooltip2.prototype.destroy = function() {
      if (this.anchorElem) {
        if (this.isTooltipRich && this.isTooltipPersistent) {
          this.anchorElem.removeEventListener("click", this.handleClick);
        } else {
          this.anchorElem.removeEventListener("mouseenter", this.handleMouseEnter);
          this.anchorElem.removeEventListener("focus", this.handleFocus);
          this.anchorElem.removeEventListener("mouseleave", this.handleMouseLeave);
          this.anchorElem.removeEventListener("touchstart", this.handleTouchstart);
          this.anchorElem.removeEventListener("touchend", this.handleTouchend);
        }
      }
      this.unlisten("transitionend", this.handleTransitionEnd);
      _super.prototype.destroy.call(this);
    };
    MDCTooltip2.prototype.setTooltipPosition = function(position) {
      this.foundation.setTooltipPosition(position);
    };
    MDCTooltip2.prototype.setAnchorBoundaryType = function(type) {
      this.foundation.setAnchorBoundaryType(type);
    };
    MDCTooltip2.prototype.setShowDelay = function(delayMs) {
      this.foundation.setShowDelay(delayMs);
    };
    MDCTooltip2.prototype.setHideDelay = function(delayMs) {
      this.foundation.setHideDelay(delayMs);
    };
    MDCTooltip2.prototype.hide = function() {
      this.foundation.hide();
    };
    MDCTooltip2.prototype.isShown = function() {
      return this.foundation.isShown();
    };
    MDCTooltip2.prototype.attachScrollHandler = function(addEventListenerFn) {
      this.foundation.attachScrollHandler(addEventListenerFn);
    };
    MDCTooltip2.prototype.removeScrollHandler = function(removeEventHandlerFn) {
      this.foundation.removeScrollHandler(removeEventHandlerFn);
    };
    MDCTooltip2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        getAttribute: function(attr) {
          return _this.root.getAttribute(attr);
        },
        setAttribute: function(attr, value) {
          _this.root.setAttribute(attr, value);
        },
        removeAttribute: function(attr) {
          _this.root.removeAttribute(attr);
        },
        addClass: function(className) {
          _this.root.classList.add(className);
        },
        hasClass: function(className) {
          return _this.root.classList.contains(className);
        },
        removeClass: function(className) {
          _this.root.classList.remove(className);
        },
        getComputedStyleProperty: function(propertyName) {
          return window.getComputedStyle(_this.root).getPropertyValue(propertyName);
        },
        setStyleProperty: function(propertyName, value) {
          _this.root.style.setProperty(propertyName, value);
        },
        setSurfaceAnimationStyleProperty: function(propertyName, value) {
          var surface = _this.root.querySelector("." + CssClasses.SURFACE_ANIMATION);
          surface === null || surface === void 0 ? void 0 : surface.style.setProperty(propertyName, value);
        },
        getViewportWidth: function() {
          return window.innerWidth;
        },
        getViewportHeight: function() {
          return window.innerHeight;
        },
        getTooltipSize: function() {
          return {
            width: _this.root.offsetWidth,
            height: _this.root.offsetHeight
          };
        },
        getAnchorBoundingRect: function() {
          return _this.anchorElem ? _this.anchorElem.getBoundingClientRect() : null;
        },
        getParentBoundingRect: function() {
          var _a, _b;
          return (_b = (_a = _this.root.parentElement) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) !== null && _b !== void 0 ? _b : null;
        },
        getAnchorAttribute: function(attr) {
          return _this.anchorElem ? _this.anchorElem.getAttribute(attr) : null;
        },
        setAnchorAttribute: function(attr, value) {
          var _a;
          (_a = _this.anchorElem) === null || _a === void 0 ? void 0 : _a.setAttribute(attr, value);
        },
        isRTL: function() {
          return getComputedStyle(_this.root).direction === "rtl";
        },
        anchorContainsElement: function(element2) {
          var _a;
          return !!((_a = _this.anchorElem) === null || _a === void 0 ? void 0 : _a.contains(element2));
        },
        tooltipContainsElement: function(element2) {
          return _this.root.contains(element2);
        },
        focusAnchorElement: function() {
          var _a;
          (_a = _this.anchorElem) === null || _a === void 0 ? void 0 : _a.focus();
        },
        registerEventHandler: function(evt, handler) {
          if (_this.root instanceof HTMLElement) {
            _this.root.addEventListener(evt, handler);
          }
        },
        deregisterEventHandler: function(evt, handler) {
          if (_this.root instanceof HTMLElement) {
            _this.root.removeEventListener(evt, handler);
          }
        },
        registerAnchorEventHandler: function(evt, handler) {
          var _a;
          (_a = _this.anchorElem) === null || _a === void 0 ? void 0 : _a.addEventListener(evt, handler);
        },
        deregisterAnchorEventHandler: function(evt, handler) {
          var _a;
          (_a = _this.anchorElem) === null || _a === void 0 ? void 0 : _a.removeEventListener(evt, handler);
        },
        registerDocumentEventHandler: function(evt, handler) {
          document.body.addEventListener(evt, handler);
        },
        deregisterDocumentEventHandler: function(evt, handler) {
          document.body.removeEventListener(evt, handler);
        },
        registerWindowEventHandler: function(evt, handler) {
          window.addEventListener(evt, handler);
        },
        deregisterWindowEventHandler: function(evt, handler) {
          window.removeEventListener(evt, handler);
        },
        notifyHidden: function() {
          _this.emit(events.HIDDEN, {});
        },
        getTooltipCaretBoundingRect: function() {
          var caret = _this.root.querySelector("." + CssClasses.TOOLTIP_CARET_TOP);
          if (!caret) {
            return null;
          }
          return caret.getBoundingClientRect();
        },
        setTooltipCaretStyle: function(propertyName, value) {
          var topCaret = _this.root.querySelector("." + CssClasses.TOOLTIP_CARET_TOP);
          var bottomCaret = _this.root.querySelector("." + CssClasses.TOOLTIP_CARET_BOTTOM);
          if (!topCaret || !bottomCaret) {
            return;
          }
          topCaret.style.setProperty(propertyName, value);
          bottomCaret.style.setProperty(propertyName, value);
        },
        clearTooltipCaretStyles: function() {
          var topCaret = _this.root.querySelector("." + CssClasses.TOOLTIP_CARET_TOP);
          var bottomCaret = _this.root.querySelector("." + CssClasses.TOOLTIP_CARET_BOTTOM);
          if (!topCaret || !bottomCaret) {
            return;
          }
          topCaret.removeAttribute("style");
          bottomCaret.removeAttribute("style");
        },
        getActiveElement: function() {
          return document.activeElement;
        }
      };
      return new MDCTooltipFoundation(adapter);
    };
    return MDCTooltip2;
  }(MDCComponent)
);

// node_modules/@smui/tooltip/dist/Tooltip.svelte
var file = "node_modules\\@smui\\tooltip\\dist\\Tooltip.svelte";
function create_fragment(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let div0_style_value;
  let div1_class_value;
  let div1_style_value;
  let div1_role_value;
  let div1_tabindex_value;
  let div1_data_mdc_tooltip_persist_value;
  let div1_data_mdc_tooltip_persistent_value;
  let div1_data_hide_tooltip_from_screenreader_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[31].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[30],
    null
  );
  let div0_levels = [
    {
      class: div0_class_value = classMap({
        [
          /*surface$class*/
          ctx[7]
        ]: true,
        "mdc-tooltip__surface": true,
        "mdc-tooltip__surface-animation": true
      })
    },
    {
      style: div0_style_value = Object.entries(
        /*surfaceAnimationStyles*/
        ctx[14]
      ).map(func).concat([
        /*surface$style*/
        ctx[8]
      ]).join(" ")
    },
    prefixFilter(
      /*$$restProps*/
      ctx[19],
      "surface$"
    )
  ];
  let div0_data = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div0_data = assign(div0_data, div0_levels[i]);
  }
  let div1_levels = [
    {
      class: div1_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-tooltip": true,
        "mdc-tooltip--rich": (
          /*rich*/
          ctx[18]
        ),
        .../*internalClasses*/
        ctx[11]
      })
    },
    {
      style: div1_style_value = Object.entries(
        /*internalStyles*/
        ctx[12]
      ).map(func_1).concat([
        /*style*/
        ctx[2]
      ]).join(" ")
    },
    {
      role: div1_role_value = /*rich*/
      ctx[18] && /*interactive*/
      ctx[5] ? "dialog" : "tooltip"
    },
    { "aria-hidden": "true" },
    { id: (
      /*id*/
      ctx[3]
    ) },
    {
      tabindex: div1_tabindex_value = /*rich*/
      ctx[18] && /*persistent*/
      ctx[4] ? -1 : void 0
    },
    {
      "data-mdc-tooltip-persist": div1_data_mdc_tooltip_persist_value = /*rich*/
      ctx[18] && /*persistent*/
      ctx[4] ? "true" : void 0
    },
    {
      "data-mdc-tooltip-persistent": div1_data_mdc_tooltip_persistent_value = /* MDC uses this attr, but document the one above */
      /*rich*/
      ctx[18] && /*persistent*/
      ctx[4] ? "true" : void 0
    },
    { "data-mdc-tooltip-has-caret": void 0 },
    {
      "data-hide-tooltip-from-screenreader": div1_data_hide_tooltip_from_screenreader_value = /*hideFromScreenreader*/
      ctx[6] ? "true" : void 0
    },
    /*internalAttrs*/
    ctx[13],
    exclude(
      /*$$restProps*/
      ctx[19],
      ["surface$"]
    )
  ];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div0, div0_data);
      add_location(div0, file, 31, 2, 927);
      set_attributes(div1, div1_data);
      add_location(div1, file, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[32](div1);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div1,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[15].call(null, div1)),
          listen_dev(
            div1,
            "transitionend",
            /*transitionend_handler*/
            ctx[33],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        1073741824)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[30],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[30]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[30],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div0, div0_data = get_spread_update(div0_levels, [
        (!current || dirty[0] & /*surface$class*/
        128 && div0_class_value !== (div0_class_value = classMap({
          [
            /*surface$class*/
            ctx2[7]
          ]: true,
          "mdc-tooltip__surface": true,
          "mdc-tooltip__surface-animation": true
        }))) && { class: div0_class_value },
        (!current || dirty[0] & /*surfaceAnimationStyles, surface$style*/
        16640 && div0_style_value !== (div0_style_value = Object.entries(
          /*surfaceAnimationStyles*/
          ctx2[14]
        ).map(func).concat([
          /*surface$style*/
          ctx2[8]
        ]).join(" "))) && { style: div0_style_value },
        dirty[0] & /*$$restProps*/
        524288 && prefixFilter(
          /*$$restProps*/
          ctx2[19],
          "surface$"
        )
      ]));
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        (!current || dirty[0] & /*className, internalClasses*/
        2050 && div1_class_value !== (div1_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-tooltip": true,
          "mdc-tooltip--rich": (
            /*rich*/
            ctx2[18]
          ),
          .../*internalClasses*/
          ctx2[11]
        }))) && { class: div1_class_value },
        (!current || dirty[0] & /*internalStyles, style*/
        4100 && div1_style_value !== (div1_style_value = Object.entries(
          /*internalStyles*/
          ctx2[12]
        ).map(func_1).concat([
          /*style*/
          ctx2[2]
        ]).join(" "))) && { style: div1_style_value },
        (!current || dirty[0] & /*interactive*/
        32 && div1_role_value !== (div1_role_value = /*rich*/
        ctx2[18] && /*interactive*/
        ctx2[5] ? "dialog" : "tooltip")) && { role: div1_role_value },
        { "aria-hidden": "true" },
        (!current || dirty[0] & /*id*/
        8) && { id: (
          /*id*/
          ctx2[3]
        ) },
        (!current || dirty[0] & /*persistent*/
        16 && div1_tabindex_value !== (div1_tabindex_value = /*rich*/
        ctx2[18] && /*persistent*/
        ctx2[4] ? -1 : void 0)) && { tabindex: div1_tabindex_value },
        (!current || dirty[0] & /*persistent*/
        16 && div1_data_mdc_tooltip_persist_value !== (div1_data_mdc_tooltip_persist_value = /*rich*/
        ctx2[18] && /*persistent*/
        ctx2[4] ? "true" : void 0)) && {
          "data-mdc-tooltip-persist": div1_data_mdc_tooltip_persist_value
        },
        (!current || dirty[0] & /*persistent*/
        16 && div1_data_mdc_tooltip_persistent_value !== (div1_data_mdc_tooltip_persistent_value = /* MDC uses this attr, but document the one above */
        /*rich*/
        ctx2[18] && /*persistent*/
        ctx2[4] ? "true" : void 0)) && {
          "data-mdc-tooltip-persistent": div1_data_mdc_tooltip_persistent_value
        },
        { "data-mdc-tooltip-has-caret": void 0 },
        (!current || dirty[0] & /*hideFromScreenreader*/
        64 && div1_data_hide_tooltip_from_screenreader_value !== (div1_data_hide_tooltip_from_screenreader_value = /*hideFromScreenreader*/
        ctx2[6] ? "true" : void 0)) && {
          "data-hide-tooltip-from-screenreader": div1_data_hide_tooltip_from_screenreader_value
        },
        dirty[0] & /*internalAttrs*/
        8192 && /*internalAttrs*/
        ctx2[13],
        dirty[0] & /*$$restProps*/
        524288 && exclude(
          /*$$restProps*/
          ctx2[19],
          ["surface$"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
      ctx[32](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var counter = 0;
var func = ([name, value]) => `${name}: ${value};`;
var func_1 = ([name, value]) => `${name}: ${value};`;
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "id",
    "unbounded",
    "xPos",
    "yPos",
    "persistent",
    "interactive",
    "hideFromScreenreader",
    "showDelay",
    "hideDelay",
    "surface$class",
    "surface$style",
    "attachScrollHandler",
    "removeScrollHandler",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $anchor;
  let $tooltip;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tooltip", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { id = "SMUI-tooltip-" + counter++ } = $$props;
  let { unbounded = false } = $$props;
  let { xPos = "detected" } = $$props;
  let { yPos = "detected" } = $$props;
  let { persistent = false } = $$props;
  let { interactive = persistent } = $$props;
  let { hideFromScreenreader = false } = $$props;
  let { showDelay = void 0 } = $$props;
  let { hideDelay = void 0 } = $$props;
  let { surface$class = "" } = $$props;
  let { surface$style = "" } = $$props;
  let element2;
  let instance2;
  let nonReactiveLocationStore = {
    setParent(value) {
      Object.defineProperty(this, "parent", { value });
    },
    setNextSibling(value) {
      Object.defineProperty(this, "nextSibling", { value });
    }
  };
  let internalClasses = {};
  let internalStyles = {};
  let internalAttrs = {};
  let surfaceAnimationStyles = {};
  let anchor = getContext("SMUI:tooltip:wrapper:anchor");
  validate_store(anchor, "anchor");
  component_subscribe($$self, anchor, (value) => $$invalidate(29, $anchor = value));
  let tooltip = getContext("SMUI:tooltip:wrapper:tooltip");
  validate_store(tooltip, "tooltip");
  component_subscribe($$self, tooltip, (value) => $$invalidate(34, $tooltip = value));
  const rich = getContext("SMUI:tooltip:rich");
  let previousAnchor = void 0;
  onMount(() => {
    $$invalidate(9, instance2 = new MDCTooltipFoundation({
      getAttribute: getAttr,
      setAttribute: addAttr,
      removeAttribute: removeAttr,
      addClass,
      hasClass,
      removeClass,
      getComputedStyleProperty: (propertyName) => {
        const element3 = getElement();
        let style2 = getComputedStyle(element3).getPropertyValue(propertyName);
        if (style2 === "auto") {
          element3.classList.add("smui-banner--force-show");
          style2 = getComputedStyle(element3).getPropertyValue(propertyName);
          element3.classList.remove("smui-banner--force-show");
        }
        return style2;
      },
      setStyleProperty: addStyle,
      setSurfaceAnimationStyleProperty: addSurfaceAnimationStyle,
      getViewportWidth: () => window.innerWidth,
      getViewportHeight: () => window.innerHeight,
      getTooltipSize: () => {
        const element3 = getElement();
        let size = {
          width: element3.offsetWidth,
          height: element3.offsetHeight
        };
        if (size.width === 0 || size.height === 0) {
          element3.classList.add("smui-banner--force-show");
          size = {
            width: element3.offsetWidth,
            height: element3.offsetHeight
          };
          element3.classList.remove("smui-banner--force-show");
        }
        return size;
      },
      getAnchorBoundingRect: () => {
        return $anchor ? $anchor.getBoundingClientRect() : null;
      },
      getParentBoundingRect: () => {
        let parent = getElement().parentElement;
        if (!rich) {
          parent = document.body;
        }
        return (parent === null || parent === void 0 ? void 0 : parent.getBoundingClientRect()) || null;
      },
      getAnchorAttribute: (attr) => {
        return $anchor ? $anchor.getAttribute(attr) : null;
      },
      setAnchorAttribute: (attr, value) => {
        $anchor && $anchor.setAttribute(attr, value);
      },
      isRTL: () => getComputedStyle(getElement()).direction === "rtl",
      anchorContainsElement: (element3) => {
        return !!($anchor && $anchor.contains(element3));
      },
      tooltipContainsElement: (element3) => {
        return getElement().contains(element3);
      },
      focusAnchorElement: () => {
        $anchor && $anchor.focus();
      },
      registerEventHandler: (evt, handler) => {
        getElement().addEventListener(evt, handler);
      },
      deregisterEventHandler: (evt, handler) => {
        getElement().removeEventListener(evt, handler);
      },
      registerAnchorEventHandler: (evt, handler) => {
        $anchor && $anchor.addEventListener(evt, handler);
      },
      deregisterAnchorEventHandler: (evt, handler) => {
        $anchor && $anchor.removeEventListener(evt, handler);
      },
      registerDocumentEventHandler: (evt, handler) => {
        document.body.addEventListener(evt, handler);
      },
      deregisterDocumentEventHandler: (evt, handler) => {
        document.body.removeEventListener(evt, handler);
      },
      registerWindowEventHandler: (evt, handler) => {
        window.addEventListener(evt, handler, evt === "scroll" && { capture: true, passive: true });
      },
      deregisterWindowEventHandler: (evt, handler) => {
        window.removeEventListener(evt, handler, evt === "scroll" && { capture: true, passive: true });
      },
      notifyHidden: () => {
        dispatch(getElement(), "SMUITooltip:hidden", void 0, void 0, true);
      },
      // TODO: figure out why MDC-Web included these caret functions, because they're entirely undocumented.
      getTooltipCaretBoundingRect: () => {
        const caret = getElement().querySelector(`.${CssClasses.TOOLTIP_CARET_TOP}`);
        if (!caret) {
          return null;
        }
        return caret.getBoundingClientRect();
      },
      setTooltipCaretStyle: (propertyName, value) => {
        const topCaret = getElement().querySelector(`.${CssClasses.TOOLTIP_CARET_TOP}`);
        const bottomCaret = getElement().querySelector(`.${CssClasses.TOOLTIP_CARET_BOTTOM}`);
        if (!topCaret || !bottomCaret) {
          return;
        }
        topCaret.style.setProperty(propertyName, value);
        bottomCaret.style.setProperty(propertyName, value);
      },
      clearTooltipCaretStyles: () => {
        const topCaret = getElement().querySelector(`.${CssClasses.TOOLTIP_CARET_TOP}`);
        const bottomCaret = getElement().querySelector(`.${CssClasses.TOOLTIP_CARET_BOTTOM}`);
        if (!topCaret || !bottomCaret) {
          return;
        }
        topCaret.removeAttribute("style");
        bottomCaret.removeAttribute("style");
      },
      getActiveElement: () => document.activeElement
    }));
    set_store_value(tooltip, $tooltip = element2, $tooltip);
    return () => {
      if ($anchor) {
        destroy($anchor);
      }
    };
  });
  onDestroy(() => {
    var _a;
    if (!rich && typeof document !== "undefined" && document.body === getElement().parentElement && nonReactiveLocationStore.parent !== getElement().parentElement && ((_a = nonReactiveLocationStore.parent) === null || _a === void 0 ? void 0 : _a.insertBefore) && nonReactiveLocationStore.nextSibling) {
      nonReactiveLocationStore.parent.insertBefore(getElement(), nonReactiveLocationStore.nextSibling);
    }
  });
  function destroy(anchor2) {
    anchor2.removeEventListener("focusout", handleAnchorFocusOut);
    if (rich && persistent) {
      anchor2.removeEventListener("click", handleAnchorActivate);
      anchor2.removeEventListener("keydown", handleAnchorActivate);
    } else {
      anchor2.removeEventListener("mouseenter", handleAnchorMouseEnter);
      anchor2.removeEventListener("focusin", handleAnchorFocus);
      anchor2.removeEventListener("mouseleave", handleAnchorMouseLeave);
      anchor2.removeEventListener("touchstart", handleAnchorTouchStart);
      anchor2.removeEventListener("touchend", handleAnchorTouchEnd);
    }
    if (rich && interactive) {
      anchor2.removeAttribute("aria-haspopup");
      anchor2.removeAttribute("aria-expanded");
      anchor2.removeAttribute("data-tooltip-id");
    } else {
      anchor2.removeAttribute("aria-describedby");
    }
    instance2.destroy();
  }
  function init2(anchor2) {
    anchor2.addEventListener("focusout", handleAnchorFocusOut);
    if (rich && persistent) {
      anchor2.addEventListener("click", handleAnchorActivate);
      anchor2.addEventListener("keydown", handleAnchorActivate);
    } else {
      anchor2.addEventListener("mouseenter", handleAnchorMouseEnter);
      anchor2.addEventListener("focusin", handleAnchorFocus);
      anchor2.addEventListener("mouseleave", handleAnchorMouseLeave);
      anchor2.addEventListener("touchstart", handleAnchorTouchStart);
      anchor2.addEventListener("touchend", handleAnchorTouchEnd);
    }
    if (rich && interactive) {
      anchor2.setAttribute("aria-haspopup", "dialog");
      anchor2.setAttribute("aria-expanded", "false");
      anchor2.setAttribute("data-tooltip-id", id);
    } else {
      anchor2.setAttribute("aria-describedby", id);
    }
    if (!rich) {
      hoistToBody();
    }
    instance2.init();
  }
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(11, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(11, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(12, internalStyles);
      } else {
        $$invalidate(12, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function addSurfaceAnimationStyle(name, value) {
    if (surfaceAnimationStyles[name] != value) {
      if (value === "" || value == null) {
        delete surfaceAnimationStyles[name];
        $$invalidate(14, surfaceAnimationStyles);
      } else {
        $$invalidate(14, surfaceAnimationStyles[name] = value, surfaceAnimationStyles);
      }
    }
  }
  function getAttr(name) {
    var _a;
    return name in internalAttrs ? (_a = internalAttrs[name]) !== null && _a !== void 0 ? _a : null : getElement().getAttribute(name);
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      $$invalidate(13, internalAttrs[name] = value, internalAttrs);
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      $$invalidate(13, internalAttrs[name] = void 0, internalAttrs);
    }
  }
  function handleAnchorFocusOut(event) {
    if (element2.contains(event.relatedTarget)) {
      return;
    }
    instance2 && instance2.hide();
  }
  function handleAnchorActivate(event) {
    if (event.type === "keydown" && event.key !== "Enter" && event.key !== " ") {
      return;
    }
    instance2 && instance2.handleAnchorClick();
  }
  function handleAnchorMouseEnter() {
    instance2 && instance2.handleAnchorMouseEnter();
  }
  function handleAnchorFocus(event) {
    instance2 && instance2.handleAnchorFocus(event);
  }
  function handleAnchorMouseLeave() {
    instance2 && instance2.handleAnchorMouseLeave();
  }
  function handleAnchorTouchStart() {
    instance2 && instance2.handleAnchorTouchstart();
  }
  function handleAnchorTouchEnd() {
    instance2 && instance2.handleAnchorTouchend();
  }
  function hoistToBody() {
    var _a, _b;
    if ($anchor && document.body !== getElement().parentNode) {
      nonReactiveLocationStore.setParent((_a = getElement().parentElement) !== null && _a !== void 0 ? _a : void 0);
      nonReactiveLocationStore.setNextSibling((_b = getElement().nextElementSibling) !== null && _b !== void 0 ? _b : void 0);
      document.body.appendChild(getElement());
    }
  }
  function attachScrollHandler(addEventListenerFn) {
    instance2 && instance2.attachScrollHandler(addEventListenerFn);
  }
  function removeScrollHandler(removeEventHandlerFn) {
    instance2 && instance2.removeScrollHandler(removeEventHandlerFn);
  }
  function getElement() {
    return element2;
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(10, element2);
    });
  }
  const transitionend_handler = () => instance2 && instance2.handleTransitionEnd();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
    if ("id" in $$new_props)
      $$invalidate(3, id = $$new_props.id);
    if ("unbounded" in $$new_props)
      $$invalidate(20, unbounded = $$new_props.unbounded);
    if ("xPos" in $$new_props)
      $$invalidate(21, xPos = $$new_props.xPos);
    if ("yPos" in $$new_props)
      $$invalidate(22, yPos = $$new_props.yPos);
    if ("persistent" in $$new_props)
      $$invalidate(4, persistent = $$new_props.persistent);
    if ("interactive" in $$new_props)
      $$invalidate(5, interactive = $$new_props.interactive);
    if ("hideFromScreenreader" in $$new_props)
      $$invalidate(6, hideFromScreenreader = $$new_props.hideFromScreenreader);
    if ("showDelay" in $$new_props)
      $$invalidate(23, showDelay = $$new_props.showDelay);
    if ("hideDelay" in $$new_props)
      $$invalidate(24, hideDelay = $$new_props.hideDelay);
    if ("surface$class" in $$new_props)
      $$invalidate(7, surface$class = $$new_props.surface$class);
    if ("surface$style" in $$new_props)
      $$invalidate(8, surface$style = $$new_props.surface$style);
    if ("$$scope" in $$new_props)
      $$invalidate(30, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    counter,
    MDCTooltipFoundation,
    AnchorBoundaryType,
    XPosition,
    YPosition,
    CssClasses,
    onMount,
    onDestroy,
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    forwardEvents,
    use,
    className,
    style,
    id,
    unbounded,
    xPos,
    yPos,
    persistent,
    interactive,
    hideFromScreenreader,
    showDelay,
    hideDelay,
    surface$class,
    surface$style,
    element: element2,
    instance: instance2,
    nonReactiveLocationStore,
    internalClasses,
    internalStyles,
    internalAttrs,
    surfaceAnimationStyles,
    anchor,
    tooltip,
    rich,
    previousAnchor,
    destroy,
    init: init2,
    hasClass,
    addClass,
    removeClass,
    addStyle,
    addSurfaceAnimationStyle,
    getAttr,
    addAttr,
    removeAttr,
    handleAnchorFocusOut,
    handleAnchorActivate,
    handleAnchorMouseEnter,
    handleAnchorFocus,
    handleAnchorMouseLeave,
    handleAnchorTouchStart,
    handleAnchorTouchEnd,
    hoistToBody,
    attachScrollHandler,
    removeScrollHandler,
    getElement,
    $anchor,
    $tooltip
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
    if ("id" in $$props)
      $$invalidate(3, id = $$new_props.id);
    if ("unbounded" in $$props)
      $$invalidate(20, unbounded = $$new_props.unbounded);
    if ("xPos" in $$props)
      $$invalidate(21, xPos = $$new_props.xPos);
    if ("yPos" in $$props)
      $$invalidate(22, yPos = $$new_props.yPos);
    if ("persistent" in $$props)
      $$invalidate(4, persistent = $$new_props.persistent);
    if ("interactive" in $$props)
      $$invalidate(5, interactive = $$new_props.interactive);
    if ("hideFromScreenreader" in $$props)
      $$invalidate(6, hideFromScreenreader = $$new_props.hideFromScreenreader);
    if ("showDelay" in $$props)
      $$invalidate(23, showDelay = $$new_props.showDelay);
    if ("hideDelay" in $$props)
      $$invalidate(24, hideDelay = $$new_props.hideDelay);
    if ("surface$class" in $$props)
      $$invalidate(7, surface$class = $$new_props.surface$class);
    if ("surface$style" in $$props)
      $$invalidate(8, surface$style = $$new_props.surface$style);
    if ("element" in $$props)
      $$invalidate(10, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(9, instance2 = $$new_props.instance);
    if ("nonReactiveLocationStore" in $$props)
      nonReactiveLocationStore = $$new_props.nonReactiveLocationStore;
    if ("internalClasses" in $$props)
      $$invalidate(11, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(12, internalStyles = $$new_props.internalStyles);
    if ("internalAttrs" in $$props)
      $$invalidate(13, internalAttrs = $$new_props.internalAttrs);
    if ("surfaceAnimationStyles" in $$props)
      $$invalidate(14, surfaceAnimationStyles = $$new_props.surfaceAnimationStyles);
    if ("anchor" in $$props)
      $$invalidate(16, anchor = $$new_props.anchor);
    if ("tooltip" in $$props)
      $$invalidate(17, tooltip = $$new_props.tooltip);
    if ("previousAnchor" in $$props)
      $$invalidate(28, previousAnchor = $$new_props.previousAnchor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*instance, previousAnchor, $anchor*/
    805306880) {
      $:
        if (instance2 && previousAnchor !== $anchor) {
          if (previousAnchor) {
            destroy(previousAnchor);
          }
          if ($anchor) {
            init2($anchor);
          }
          $$invalidate(28, previousAnchor = $anchor);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, unbounded*/
    1049088) {
      $:
        if (instance2) {
          instance2.setAnchorBoundaryType(AnchorBoundaryType[unbounded ? "UNBOUNDED" : "BOUNDED"]);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, xPos, yPos*/
    6291968) {
      $:
        if (instance2) {
          instance2.setTooltipPosition({
            xPos: XPosition[xPos.toUpperCase()],
            yPos: YPosition[yPos.toUpperCase()]
          });
        }
    }
    if ($$self.$$.dirty[0] & /*instance, showDelay*/
    8389120) {
      $:
        if (instance2 && showDelay != null) {
          instance2.setShowDelay(showDelay);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, hideDelay*/
    16777728) {
      $:
        if (instance2 && hideDelay != null) {
          instance2.setHideDelay(hideDelay);
        }
    }
  };
  return [
    use,
    className,
    style,
    id,
    persistent,
    interactive,
    hideFromScreenreader,
    surface$class,
    surface$style,
    instance2,
    element2,
    internalClasses,
    internalStyles,
    internalAttrs,
    surfaceAnimationStyles,
    forwardEvents,
    anchor,
    tooltip,
    rich,
    $$restProps,
    unbounded,
    xPos,
    yPos,
    showDelay,
    hideDelay,
    attachScrollHandler,
    removeScrollHandler,
    getElement,
    previousAnchor,
    $anchor,
    $$scope,
    slots,
    div1_binding,
    transitionend_handler
  ];
}
var Tooltip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 0,
        class: 1,
        style: 2,
        id: 3,
        unbounded: 20,
        xPos: 21,
        yPos: 22,
        persistent: 4,
        interactive: 5,
        hideFromScreenreader: 6,
        showDelay: 23,
        hideDelay: 24,
        surface$class: 7,
        surface$style: 8,
        attachScrollHandler: 25,
        removeScrollHandler: 26,
        getElement: 27
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tooltip",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get unbounded() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set unbounded(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xPos() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xPos(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yPos() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yPos(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get persistent() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set persistent(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideFromScreenreader() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideFromScreenreader(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showDelay() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showDelay(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideDelay() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideDelay(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get surface$class() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set surface$class(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get surface$style() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set surface$style(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get attachScrollHandler() {
    return this.$$.ctx[25];
  }
  set attachScrollHandler(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get removeScrollHandler() {
    return this.$$.ctx[26];
  }
  set removeScrollHandler(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[27];
  }
  set getElement(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tooltip_default = Tooltip;

// node_modules/@smui/tooltip/dist/Wrapper.svelte
var file2 = "node_modules\\@smui\\tooltip\\dist\\Wrapper.svelte";
function create_else_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(14:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  let div_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let div_levels = [
    {
      class: div_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-tooltip-wrapper--rich": true
      })
    },
    /*$$restProps*/
    ctx[7]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file2, 1, 2, 13);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[13](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[4].call(null, div))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*className*/
        2 && div_class_value !== (div_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-tooltip-wrapper--rich": true
        }))) && { class: div_class_value },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[13](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(1:0) {#if rich}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*rich*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "rich", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $tooltip;
  let $anchor;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Wrapper", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { rich = false } = $$props;
  let element2;
  const anchor = writable(void 0);
  validate_store(anchor, "anchor");
  component_subscribe($$self, anchor, (value) => $$invalidate(10, $anchor = value));
  const tooltip = writable(void 0);
  validate_store(tooltip, "tooltip");
  component_subscribe($$self, tooltip, (value) => $$invalidate(9, $tooltip = value));
  setContext("SMUI:tooltip:wrapper:anchor", anchor);
  setContext("SMUI:tooltip:wrapper:tooltip", tooltip);
  setContext("SMUI:tooltip:rich", rich);
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(3, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("rich" in $$new_props)
      $$invalidate(2, rich = $$new_props.rich);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    writable,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    rich,
    element: element2,
    anchor,
    tooltip,
    getElement,
    $tooltip,
    $anchor
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("rich" in $$props)
      $$invalidate(2, rich = $$new_props.rich);
    if ("element" in $$props)
      $$invalidate(3, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$tooltip, $anchor*/
    1536) {
      $:
        if ($tooltip && !$anchor) {
          set_store_value(anchor, $anchor = $tooltip.previousElementSibling, $anchor);
        }
    }
  };
  return [
    use,
    className,
    rich,
    element2,
    forwardEvents,
    anchor,
    tooltip,
    $$restProps,
    getElement,
    $tooltip,
    $anchor,
    $$scope,
    slots,
    div_binding
  ];
}
var Wrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment2, safe_not_equal, { use: 0, class: 1, rich: 2, getElement: 8 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Wrapper",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error("<Wrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Wrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rich() {
    throw new Error("<Wrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rich(value) {
    throw new Error("<Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[8];
  }
  set getElement(value) {
    throw new Error("<Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Wrapper_default = Wrapper;

// node_modules/@smui/tooltip/dist/Title.js
var Title_default = classAdderBuilder({
  class: "mdc-tooltip__title",
  tag: "h2"
});

// node_modules/@smui/tooltip/dist/Content.js
var Content_default = classAdderBuilder({
  class: "mdc-tooltip__content",
  tag: "div"
});

// node_modules/@smui/tooltip/dist/Link.js
var Link_default = classAdderBuilder({
  class: "mdc-tooltip__content-link",
  tag: "a"
});

// node_modules/@smui/tooltip/dist/RichActions.js
var RichActions_default = classAdderBuilder({
  class: "mdc-tooltip--rich-actions",
  tag: "div",
  contexts: {
    "SMUI:button:context": "tooltip:rich-actions"
  }
});

// node_modules/@smui/tooltip/dist/index.js
var dist_default = Tooltip_default;
export {
  Content_default as Content,
  Link_default as Link,
  RichActions_default as RichActions,
  Title_default as Title,
  Wrapper_default as Wrapper,
  dist_default as default
};
/*! Bundled license information:

@material/tooltip/adapter.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/tooltip/constants.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/tooltip/foundation.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/tooltip/component.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/tooltip/index.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)
*/
//# sourceMappingURL=@smui_tooltip.js.map
