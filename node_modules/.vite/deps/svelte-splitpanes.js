import {
  writable
} from "./chunk-DY7FSUYH.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  afterUpdate,
  append_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  component_subscribe,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  globals,
  hasContext,
  init,
  insert_dev,
  listen_dev,
  mount_component,
  onDestroy,
  onMount,
  safe_not_equal,
  setContext,
  set_store_value,
  space,
  tick,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-K6MJRMI7.js";
import "./chunk-FAW2VN4A.js";

// node_modules/svelte-splitpanes/internal/GatheringRound.svelte
function create_fragment(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var gatheringKey = {};
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GatheringRound", slots, ["default"]);
  setContext(gatheringKey, true);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GatheringRound> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ gatheringKey, setContext });
  return [$$scope, slots];
}
var GatheringRound = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GatheringRound",
      options,
      id: create_fragment.name
    });
  }
};
var GatheringRound_default = GatheringRound;

// node_modules/svelte-splitpanes/internal/env.js
var browser = import.meta.env != null && import.meta.env.SSR != null ? !import.meta.env.SSR : typeof window !== "undefined";

// node_modules/svelte-splitpanes/internal/utils/sizing.js
function pxToNumber(pxString) {
  if (!pxString.endsWith("px")) {
    return void 0;
  }
  const num = parseFloat(pxString.slice(0, pxString.length - 2));
  return isNaN(num) ? void 0 : num;
}
var getDimensionName = (horizontal) => horizontal ? "height" : "width";

// node_modules/svelte-splitpanes/internal/utils/styling.js
var calcComputedStyle = (element2) => window.getComputedStyle(element2);

// node_modules/svelte-splitpanes/internal/utils/position.js
var getElementRect = (element2) => element2.getBoundingClientRect();
var getBordersSizeOffsets = (computedStyle, calcEnds = true) => {
  if (computedStyle.getPropertyValue("box-sizing") === "border-box") {
    return void 0;
  }
  const left = pxToNumber(computedStyle.getPropertyValue("border-left-width"));
  if (left === void 0) {
    console.error("Splitpanes Error: Fail to parse container `border-left-width`.");
    return void 0;
  }
  const top = pxToNumber(computedStyle.getPropertyValue("border-top-width"));
  if (top === void 0) {
    console.error("Splitpanes Error: Fail to parse container `border-top-width`.");
    return void 0;
  }
  const result = { left, top };
  if (calcEnds) {
    const right = pxToNumber(computedStyle.getPropertyValue("border-right-width"));
    if (right === void 0) {
      console.error("Splitpanes Error: Fail to parse container `border-right-width`.");
      return void 0;
    }
    const bottom = pxToNumber(computedStyle.getPropertyValue("border-bottom-width"));
    if (bottom === void 0) {
      console.error("Splitpanes Error: Fail to parse container `border-bottom-width`.");
      return void 0;
    }
    const resultExtended = result;
    resultExtended.right = right;
    resultExtended.bottom = bottom;
  }
  return result;
};
function elementRectWithoutBorder(element2, computedStyle) {
  if (!computedStyle) {
    computedStyle = calcComputedStyle(element2);
  }
  const rect = getElementRect(element2);
  const borderOffsets = getBordersSizeOffsets(computedStyle, true) || { left: 0, top: 0, right: 0, bottom: 0 };
  return {
    width: rect.width - borderOffsets.left - borderOffsets.right,
    height: rect.height - borderOffsets.top - borderOffsets.bottom,
    left: rect.left + borderOffsets.left,
    top: rect.top + borderOffsets.top
  };
}
var positionDiff = (to, from) => ({
  left: to.left - from.left,
  top: to.top - from.top
});
function getGlobalMousePosition(event) {
  const eventMouse = event;
  const eventTouch = event;
  const { clientX, clientY } = "ontouchstart" in window && eventTouch.touches ? eventTouch.touches[0] : eventMouse;
  return { left: clientX, top: clientY };
}

// node_modules/svelte-splitpanes/internal/utils/array.js
function sumPartial(arr, start, end, valueFunction) {
  let sum = 0;
  for (let i = start; i < end; i++) {
    sum += valueFunction(arr[i], i);
  }
  return sum;
}

// node_modules/svelte-splitpanes/Splitpanes.svelte
var { console: console_1 } = globals;
var file = "node_modules\\svelte-splitpanes\\Splitpanes.svelte";
function add_css(target) {
  append_styles(target, "svelte-czzhnw", 'div.splitpanes--horizontal.splitpanes--dragging{cursor:row-resize}div.splitpanes--vertical.splitpanes--dragging{cursor:col-resize}.splitpanes{display:flex;width:100%;height:100%}.splitpanes--vertical{flex-direction:row}.splitpanes--horizontal{flex-direction:column}.splitpanes--dragging *{user-select:none}.splitpanes__pane{width:100%;height:100%;overflow:hidden}.splitpanes--vertical .splitpanes__pane{transition:width 0.2s ease-out}.splitpanes--horizontal .splitpanes__pane{transition:height 0.2s ease-out}.splitpanes--vertical>.splitpanes__pane{transition:width 0.2s ease-out}.splitpanes--horizontal>.splitpanes__pane{transition:height 0.2s ease-out}.splitpanes--dragging .splitpanes__pane{transition:none;pointer-events:none}.splitpanes--freeze .splitpanes__pane{transition:none}.splitpanes__splitter{touch-action:none}.splitpanes--vertical>.splitpanes__splitter{min-width:1px}.splitpanes--horizontal>.splitpanes__splitter{min-height:1px}.splitpanes.default-theme .splitpanes__pane{background-color:#f2f2f2}.splitpanes.default-theme .splitpanes__splitter{background-color:#fff;box-sizing:border-box;position:relative;flex-shrink:0}.splitpanes.default-theme .splitpanes__splitter:before,.splitpanes.default-theme .splitpanes__splitter:after{content:"";position:absolute;top:50%;left:50%;background-color:rgba(0, 0, 0, 0.15);transition:background-color 0.3s}.splitpanes.default-theme .splitpanes__splitter:hover:before,.splitpanes.default-theme .splitpanes__splitter:hover:after{background-color:rgba(0, 0, 0, 0.25)}.splitpanes.default-theme .splitpanes__splitter:first-child{cursor:auto}.default-theme.splitpanes .splitpanes .splitpanes__splitter{z-index:1}.default-theme.splitpanes--vertical>.splitpanes__splitter,.default-theme .splitpanes--vertical>.splitpanes__splitter{width:7px;border-left:1px solid #eee;cursor:col-resize}.default-theme.splitpanes--vertical>.splitpanes__splitter:before,.default-theme.splitpanes--vertical>.splitpanes__splitter:after,.default-theme .splitpanes--vertical>.splitpanes__splitter:before,.default-theme .splitpanes--vertical>.splitpanes__splitter:after{transform:translateY(-50%);width:1px;height:30px}.default-theme.splitpanes--vertical>.splitpanes__splitter:before,.default-theme .splitpanes--vertical>.splitpanes__splitter:before{margin-left:-2px}.default-theme.splitpanes--vertical>.splitpanes__splitter:after,.default-theme .splitpanes--vertical>.splitpanes__splitter:after{margin-left:1px}.default-theme.splitpanes--horizontal>.splitpanes__splitter,.default-theme .splitpanes--horizontal>.splitpanes__splitter{height:7px;border-top:1px solid #eee;cursor:row-resize}.default-theme.splitpanes--horizontal>.splitpanes__splitter:before,.default-theme.splitpanes--horizontal>.splitpanes__splitter:after,.default-theme .splitpanes--horizontal>.splitpanes__splitter:before,.default-theme .splitpanes--horizontal>.splitpanes__splitter:after{transform:translateX(-50%);width:30px;height:1px}.default-theme.splitpanes--horizontal>.splitpanes__splitter:before,.default-theme .splitpanes--horizontal>.splitpanes__splitter:before{margin-top:-2px}.default-theme.splitpanes--horizontal>.splitpanes__splitter:after,.default-theme .splitpanes--horizontal>.splitpanes__splitter:after{margin-top:1px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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 */');
}
function create_if_block(ctx) {
  let gatheringround;
  let current;
  gatheringround = new GatheringRound_default({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(gatheringround.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(gatheringround, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const gatheringround_changes = {};
      if (dirty[0] & /*$$scope*/
      262144) {
        gatheringround_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gatheringround.$set(gatheringround_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(gatheringround.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(gatheringround.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(gatheringround, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(771:1) {#if !browser}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(772:2) <GatheringRound>",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  let if_block = !browser && create_if_block(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      attr_dev(
        div,
        "id",
        /*id*/
        ctx[0]
      );
      attr_dev(div, "class", div_class_value = `splitpanes ${/*theme*/
      ctx[3] || ""} ${/*clazz*/
      ctx[4] || ""}`);
      attr_dev(
        div,
        "style",
        /*style*/
        ctx[2]
      );
      toggle_class(
        div,
        "splitpanes--horizontal",
        /*horizontal*/
        ctx[1]
      );
      toggle_class(div, "splitpanes--vertical", !/*horizontal*/
      ctx[1]);
      toggle_class(
        div,
        "splitpanes--dragging",
        /*isMouseDown*/
        ctx[7] || /*isDragging*/
        ctx[8]
      );
      toggle_class(div, "splitpanes--freeze", !/*isAfterInitialTimeoutZero*/
      ctx[6]);
      add_location(div, file, 760, 0, 32221);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[17](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!browser)
        if_block.p(ctx2, dirty);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*id*/
      1) {
        attr_dev(
          div,
          "id",
          /*id*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*theme, clazz*/
      24 && div_class_value !== (div_class_value = `splitpanes ${/*theme*/
      ctx2[3] || ""} ${/*clazz*/
      ctx2[4] || ""}`)) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*style*/
      4) {
        attr_dev(
          div,
          "style",
          /*style*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*theme, clazz, horizontal*/
      26) {
        toggle_class(
          div,
          "splitpanes--horizontal",
          /*horizontal*/
          ctx2[1]
        );
      }
      if (!current || dirty[0] & /*theme, clazz, horizontal*/
      26) {
        toggle_class(div, "splitpanes--vertical", !/*horizontal*/
        ctx2[1]);
      }
      if (!current || dirty[0] & /*theme, clazz, isMouseDown, isDragging*/
      408) {
        toggle_class(
          div,
          "splitpanes--dragging",
          /*isMouseDown*/
          ctx2[7] || /*isDragging*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*theme, clazz, isAfterInitialTimeoutZero*/
      88) {
        toggle_class(div, "splitpanes--freeze", !/*isAfterInitialTimeoutZero*/
        ctx2[6]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[17](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var KEY = {};
function instance2($$self, $$props, $$invalidate) {
  let $veryFirstPaneKey;
  let $showFirstSplitter;
  let $isHorizontal;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Splitpanes", slots, ["default"]);
  let { id = void 0 } = $$props;
  let { horizontal = false } = $$props;
  let { pushOtherPanes = true } = $$props;
  let { dblClickSplitter = true } = $$props;
  let { rtl = "auto" } = $$props;
  let { firstSplitter = false } = $$props;
  let { style = null } = $$props;
  let { theme = "default-theme" } = $$props;
  let { class: clazz = "" } = $$props;
  const dispatch = createEventDispatcher();
  let container;
  let isReady = false;
  let isAwaitingPaneReset = false;
  let isAfterInitialTimeoutZero = false;
  let isMouseDown = false;
  let isDragging = false;
  let activeSplitter = -1;
  let clickedSplitter = -1;
  let timeoutId;
  let panes = new Array();
  let isHorizontal = writable(horizontal);
  validate_store(isHorizontal, "isHorizontal");
  component_subscribe($$self, isHorizontal, (value) => $$invalidate(31, $isHorizontal = value));
  const showFirstSplitter = writable(firstSplitter);
  validate_store(showFirstSplitter, "showFirstSplitter");
  component_subscribe($$self, showFirstSplitter, (value) => $$invalidate(30, $showFirstSplitter = value));
  const veryFirstPaneKey = writable(void 0);
  validate_store(veryFirstPaneKey, "veryFirstPaneKey");
  component_subscribe($$self, veryFirstPaneKey, (value) => $$invalidate(29, $veryFirstPaneKey = value));
  let activeSplitterElement = null;
  let activeSplitterDrag = null;
  let ssrPaneDefinedSizeSum = 0;
  let ssrPaneUndefinedSizeCount = 0;
  function ssrRegisterPaneSize(size) {
    if (size == null) {
      ++ssrPaneUndefinedSizeCount;
    } else {
      ssrPaneDefinedSizeSum += size;
    }
  }
  const onPaneInit = (key) => {
    if ($veryFirstPaneKey === void 0) {
      set_store_value(veryFirstPaneKey, $veryFirstPaneKey = key, $veryFirstPaneKey);
    }
    return {
      undefinedPaneInitSize: browser ? 0 : (100 - ssrPaneDefinedSizeSum) / ssrPaneUndefinedSizeCount
    };
  };
  setContext(KEY, {
    showFirstSplitter,
    veryFirstPaneKey,
    isHorizontal,
    ssrRegisterPaneSize: browser ? void 0 : ssrRegisterPaneSize,
    onPaneInit,
    clientOnly: browser ? { onPaneAdd, onPaneRemove } : void 0
  });
  function onPaneAdd(pane) {
    let index = -1;
    Array.from(pane.element.parentNode.children).some((el) => {
      if (el.className.includes("splitpanes__pane"))
        index++;
      return el === pane.element;
    });
    if (index === 0) {
      set_store_value(veryFirstPaneKey, $veryFirstPaneKey = pane.key, $veryFirstPaneKey);
    }
    panes.splice(index, 0, pane);
    for (let i = 0; i < panes.length; i++) {
      panes[i].index = i;
    }
    if (isReady) {
      tickAndResetPaneSizes().then(() => {
        pane.isReady = true;
        dispatch("pane-add", { index, panes: prepareSizeEvent() });
      });
    }
    const paneForward = (cb, includingFirst = true) => (value) => {
      if (includingFirst || pane.index > 0) {
        cb(value, pane);
      }
    };
    return {
      onSplitterDown: paneForward(onMouseDown, false),
      onSplitterClick: paneForward(onSplitterClick, false),
      onSplitterDblClick: paneForward(onSplitterDblClick),
      onPaneClick: paneForward(onPaneClick),
      reportGivenSizeChange: paneForward(reportGivenSizeChange)
    };
  }
  async function onPaneRemove(key) {
    const index = panes.findIndex((p) => p.key === key);
    if (index >= 0) {
      const removed = panes.splice(index, 1)[0];
      for (let i = 0; i < panes.length; i++) {
        panes[i].index = i;
      }
      if (index === 0) {
        set_store_value(veryFirstPaneKey, $veryFirstPaneKey = panes.length > 0 ? panes[0].key : void 0, $veryFirstPaneKey);
      }
      if (isReady) {
        await tickAndResetPaneSizes();
        dispatch("pane-remove", { removed, panes: prepareSizeEvent() });
      }
    }
  }
  function onPaneClick(_event, pane) {
    dispatch("pane-click", pane);
  }
  function reportGivenSizeChange(newGivenSize, pane) {
    pane.setSz(newGivenSize);
    tickAndResetPaneSizes();
  }
  onMount(() => {
    verifyAndUpdatePanesOrder();
    resetPaneSizes();
    for (let i = 0; i < panes.length; i++) {
      panes[i].isReady = true;
    }
    isReady = true;
    dispatch("ready");
    setTimeout(
      () => {
        $$invalidate(6, isAfterInitialTimeoutZero = true);
      },
      0
    );
  });
  if (browser) {
    onDestroy(() => {
      if (isReady) {
        unbindEvents();
      }
      isReady = false;
    });
  }
  afterUpdate(() => {
    verifyAndUpdatePanesOrder();
  });
  function isRTL(containerComputedStyle) {
    if (rtl === "auto") {
      try {
        return (containerComputedStyle ?? calcComputedStyle(container)).direction === "rtl";
      } catch (err) {
      }
    }
    return rtl === true;
  }
  function bindEvents() {
    document.body.style.cursor = isHorizontal ? "col-resize" : "row-resize";
    document.addEventListener("mousemove", onMouseMove, { passive: false });
    document.addEventListener("mouseup", onMouseUp);
    if ("ontouchstart" in window) {
      document.addEventListener("touchmove", onMouseMove, { passive: false });
      document.addEventListener("touchend", onMouseUp);
    }
  }
  function unbindEvents() {
    document.body.style.cursor = "";
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
    if ("ontouchstart" in window) {
      document.removeEventListener("touchmove", onMouseMove);
      document.removeEventListener("touchend", onMouseUp);
    }
  }
  const isSplitterElement = (node) => node.nodeType === Node.ELEMENT_NODE && node.classList.contains("splitpanes__splitter");
  function getOrientedDiff(drag, elementSize, isRTL2) {
    let tdrag = drag[horizontal ? "top" : "left"];
    if (isRTL2 && !horizontal)
      tdrag = elementSize - tdrag;
    return tdrag;
  }
  const getCurrentDimensionName = () => getDimensionName(horizontal);
  function onMouseDown(event, splitterPane) {
    $$invalidate(7, isMouseDown = true);
    activeSplitter = splitterPane.index;
    splitterPane.setSplitterActive(true);
    const paneElement = splitterPane.element;
    let activeSplitterNode = paneElement;
    while (activeSplitterNode != null) {
      activeSplitterNode = activeSplitterNode.previousSibling;
      if (isSplitterElement(activeSplitterNode)) {
        break;
      }
    }
    if (activeSplitterNode == null) {
      console.error("Splitpane Error: Active splitter wasn't found!");
      return;
    }
    activeSplitterElement = activeSplitterNode;
    const globalMousePosition = getGlobalMousePosition(event);
    const splitterRect = getElementRect(activeSplitterElement);
    activeSplitterDrag = getOrientedDiff(positionDiff(globalMousePosition, splitterRect), splitterRect[getCurrentDimensionName()], isRTL());
    bindEvents();
  }
  function onMouseMove(event) {
    if (isMouseDown) {
      event.preventDefault();
      $$invalidate(8, isDragging = true);
      const globalMousePosition = getGlobalMousePosition(event);
      const containerComputedStyle = calcComputedStyle(container);
      const containerRectWithoutBorder = elementRectWithoutBorder(container, containerComputedStyle);
      const containerSizeWithoutBorder = containerRectWithoutBorder[getCurrentDimensionName()];
      const _isRTL = isRTL(containerComputedStyle);
      const currentMouseDrag = positionDiff(globalMousePosition, containerRectWithoutBorder);
      const tdrag = getOrientedDiff(currentMouseDrag, containerSizeWithoutBorder, _isRTL);
      calculatePanesSize(tdrag, containerSizeWithoutBorder);
      dispatch("resize", prepareSizeEvent());
    }
  }
  function onMouseUp() {
    if (isDragging) {
      dispatch("resized", prepareSizeEvent());
    }
    $$invalidate(7, isMouseDown = false);
    const pane = panes[activeSplitter];
    pane.setSplitterActive(false);
    setTimeout(
      () => {
        $$invalidate(8, isDragging = false);
        unbindEvents();
      },
      100
    );
  }
  function onSplitterClick(event, splitterPane) {
    if ("ontouchstart" in window) {
      event.preventDefault();
      const splitterIndex = splitterPane.index;
      if (dblClickSplitter) {
        if (clickedSplitter === splitterIndex) {
          if (timeoutId)
            clearTimeout(timeoutId);
          timeoutId = null;
          onSplitterDblClick(event, splitterPane);
          clickedSplitter = -1;
        } else {
          clickedSplitter = splitterIndex;
          timeoutId = setTimeout(
            () => {
              clickedSplitter = -1;
            },
            500
          );
        }
      }
    }
    if (!isDragging)
      dispatch("splitter-click", splitterPane);
  }
  function onSplitterDblClick(_event, splitterPane) {
    const splitterIndex = splitterPane.index;
    let totalMinSizes = 0;
    for (let i = 0; i < panes.length; i++) {
      const pane = panes[i];
      if (i !== splitterIndex) {
        totalMinSizes += pane.min();
      }
    }
    const maxExtendedSize = Math.min(Math.max(0, 100 - totalMinSizes), splitterPane.max());
    const totalMaxExtendedPlusMinSizes = totalMinSizes + maxExtendedSize;
    if (totalMaxExtendedPlusMinSizes >= 100) {
      for (let i = 0; i < panes.length; i++) {
        const pane = panes[i];
        if (pane !== splitterPane) {
          pane.setSz(pane.min());
        } else {
          pane.setSz(100 - totalMinSizes);
        }
      }
    } else {
      let leftSpare = 100 - totalMaxExtendedPlusMinSizes;
      splitterPane.setSz(maxExtendedSize);
      const giveBest = (pane) => {
        const min = pane.min();
        const max = pane.max();
        const szExtra = Math.min(Math.max(0, leftSpare), max - min);
        pane.setSz(min + szExtra);
        leftSpare -= szExtra;
      };
      for (let i = splitterIndex - 1; i >= 0; i--)
        giveBest(panes[i]);
      for (let i = splitterIndex + 1; i < panes.length; i++)
        giveBest(panes[i]);
      if (leftSpare != 0) {
        console.warn("Splitpanes: there is a left spare size after computation of splitter double click, which means there are issues on the size constains of the panes.");
      }
    }
    dispatch("pane-maximize", splitterPane);
    dispatch("resized", prepareSizeEvent());
    $$invalidate(7, isMouseDown = false);
  }
  function prepareSizeEvent() {
    const arr = new Array(panes.length);
    for (let i = 0; i < panes.length; i++) {
      const pane = panes[i];
      arr[i] = {
        min: pane.min(),
        max: pane.max(),
        size: pane.sz(),
        snap: pane.snap()
      };
    }
    return arr;
  }
  function getCurrentDragPercentage(tdrag, containerSizeWithoutBorder) {
    const splitterSize = (node) => getElementRect(node)[getCurrentDimensionName()];
    const activeSplitterSize = splitterSize(activeSplitterElement);
    let splittersTotalSizeBefore = 0;
    let currentBeforeNode = activeSplitterElement.previousSibling;
    while (currentBeforeNode != null) {
      if (isSplitterElement(currentBeforeNode)) {
        splittersTotalSizeBefore += splitterSize(currentBeforeNode);
      }
      currentBeforeNode = currentBeforeNode.previousSibling;
    }
    let splittersTotalSizeAfter = 0;
    let currentAfterNode = activeSplitterElement.nextSibling;
    while (currentAfterNode != null) {
      if (isSplitterElement(currentAfterNode)) {
        splittersTotalSizeAfter += splitterSize(currentAfterNode);
      }
      currentAfterNode = currentAfterNode.nextSibling;
    }
    const totalSplitterBefore = splittersTotalSizeBefore + activeSplitterDrag;
    const totalSplitter = splittersTotalSizeBefore + activeSplitterSize + splittersTotalSizeAfter;
    return (tdrag - totalSplitterBefore) / (containerSizeWithoutBorder - totalSplitter) * 100;
  }
  function calculatePanesSize(tdrag, containerSizeWithoutBorder) {
    let paneBeforeIndex = activeSplitter - 1;
    let paneBefore = panes[paneBeforeIndex];
    let paneAfterIndex = activeSplitter;
    let paneAfter = panes[paneAfterIndex];
    let sums = {
      prevPanesSize: sumPrevPanesSize(paneBeforeIndex),
      nextPanesSize: sumNextPanesSize(paneAfterIndex),
      prevReachedMinPanes: 0,
      nextReachedMinPanes: 0
    };
    const minDrag = 0 + (pushOtherPanes ? 0 : sums.prevPanesSize);
    const maxDrag = 100 - (pushOtherPanes ? 0 : sums.nextPanesSize);
    const mouseDragPercentage = Math.max(Math.min(getCurrentDragPercentage(tdrag, containerSizeWithoutBorder), maxDrag), minDrag);
    const paneBeforeSnap = sums.prevPanesSize + paneBefore.min() + paneBefore.snap();
    const paneAfterSnap = 100 - (sums.nextPanesSize + paneAfter.min() + paneAfter.snap());
    let dragPercentage = mouseDragPercentage;
    let snapped = false;
    if (mouseDragPercentage <= paneBeforeSnap) {
      if (mouseDragPercentage > sums.prevPanesSize + paneBefore.min()) {
        dragPercentage = Math.max(paneBefore.min() + sums.prevPanesSize, 100 - (paneAfter.max() + sums.nextPanesSize));
        snapped = true;
      }
    } else if (mouseDragPercentage >= paneAfterSnap) {
      if (mouseDragPercentage < 100 - sums.nextPanesSize - paneAfter.min()) {
        dragPercentage = Math.min(100 - (paneAfter.min() + sums.nextPanesSize), paneBefore.max() + sums.prevPanesSize);
        snapped = true;
      }
    }
    const paneBeforeMaxReached = paneBefore.max() < 100 && dragPercentage >= paneBefore.max() + sums.prevPanesSize;
    const paneAfterMaxReached = paneAfter.max() < 100 && dragPercentage <= 100 - (paneAfter.max() + sums.nextPanesSize);
    if (paneBeforeMaxReached || paneAfterMaxReached) {
      if (paneBeforeMaxReached) {
        paneBefore.setSz(paneBefore.max());
        paneAfter.setSz(Math.max(100 - paneBefore.max() - sums.prevPanesSize - sums.nextPanesSize, 0));
      } else {
        paneBefore.setSz(Math.max(100 - paneAfter.max() - sums.prevPanesSize - sums.nextPanesSize, 0));
        paneAfter.setSz(paneAfter.max());
      }
    } else {
      if (pushOtherPanes && !snapped) {
        const vars = doPushOtherPanes(sums, dragPercentage);
        if (!vars) {
          return;
        }
        ({ sums, paneBeforeIndex, paneAfterIndex } = vars);
        paneBefore = panes[paneBeforeIndex];
        paneAfter = panes[paneAfterIndex];
      }
      if (paneBeforeIndex != null) {
        paneBefore.setSz(Math.min(Math.max(dragPercentage - sums.prevPanesSize - sums.prevReachedMinPanes, paneBefore.min()), paneBefore.max()));
      }
      if (paneAfterIndex != null) {
        paneAfter.setSz(Math.min(Math.max(100 - dragPercentage - sums.nextPanesSize - sums.nextReachedMinPanes, paneAfter.min()), paneAfter.max()));
      }
    }
  }
  function doPushOtherPanes(sums, dragPercentage) {
    var _a, _b;
    const splitterIndex = activeSplitter - 1;
    let paneBeforeIndex = splitterIndex;
    let paneAfterIndex = splitterIndex + 1;
    if (dragPercentage < sums.prevPanesSize + panes[paneBeforeIndex].min()) {
      paneBeforeIndex = (_a = findPrevExpandedPane(splitterIndex)) == null ? void 0 : _a.index;
      sums.prevReachedMinPanes = 0;
      if (paneBeforeIndex < splitterIndex) {
        for (let i = 0; i < panes.length; i++) {
          const pane = panes[i];
          if (i > paneBeforeIndex && i <= splitterIndex) {
            pane.setSz(pane.min());
            sums.prevReachedMinPanes += pane.min();
          }
        }
      }
      sums.prevPanesSize = sumPrevPanesSize(paneBeforeIndex);
      if (paneBeforeIndex == null) {
        sums.prevReachedMinPanes = 0;
        panes[0].setSz(panes[0].min());
        for (let i = 0; i < panes.length; i++) {
          const pane = panes[i];
          if (i > 0 && i <= splitterIndex) {
            pane.setSz(pane.min());
            sums.prevReachedMinPanes += pane.min();
          }
        }
        panes[paneAfterIndex].setSz(100 - sums.prevReachedMinPanes - panes[0].min() - sums.prevPanesSize - sums.nextPanesSize);
        return null;
      }
    }
    if (dragPercentage > 100 - sums.nextPanesSize - panes[paneAfterIndex].min()) {
      paneAfterIndex = (_b = findNextExpandedPane(splitterIndex)) == null ? void 0 : _b.index;
      sums.nextReachedMinPanes = 0;
      if (paneAfterIndex > splitterIndex + 1) {
        for (let i = 0; i < panes.length; i++) {
          const pane = panes[i];
          if (i > splitterIndex && i < paneAfterIndex) {
            pane.setSz(pane.min());
            sums.nextReachedMinPanes += pane.min();
          }
        }
      }
      sums.nextPanesSize = sumNextPanesSize(paneAfterIndex);
      const panesCount = panes.length;
      if (paneAfterIndex == null) {
        sums.nextReachedMinPanes = 0;
        panes[panesCount - 1].setSz(panes[panesCount - 1].min());
        for (let i = 0; i < panes.length; i++) {
          const pane = panes[i];
          if (i < panesCount - 1 && i >= splitterIndex + 1) {
            pane.setSz(pane.min());
            sums.nextReachedMinPanes += pane.min();
          }
        }
        panes[paneBeforeIndex].setSz(100 - sums.prevPanesSize - sums.nextReachedMinPanes - panes[panesCount - 1].min() - sums.nextPanesSize);
        return null;
      }
    }
    return { sums, paneBeforeIndex, paneAfterIndex };
  }
  const getSizeOfPane = (pane) => pane.sz();
  const sumPrevPanesSize = (splitterIndex) => sumPartial(panes, 0, splitterIndex, getSizeOfPane);
  const sumNextPanesSize = (splitterIndex) => sumPartial(panes, splitterIndex + 1, panes.length, getSizeOfPane);
  const findPrevExpandedPane = (splitterIndex) => [...panes].reverse().find((p) => p.index < splitterIndex && p.sz() > p.min());
  const findNextExpandedPane = (splitterIndex) => panes.find((p) => p.index > splitterIndex + 1 && p.sz() > p.min());
  async function tickAndResetPaneSizes() {
    isAwaitingPaneReset = true;
    await tick();
    if (isAwaitingPaneReset) {
      resetPaneSizes();
      isAwaitingPaneReset = false;
    }
  }
  function resetPaneSizes() {
    equalize();
    if (isReady)
      dispatch("resized", prepareSizeEvent());
  }
  function equalize() {
    if (panes.length === 0) {
      return;
    }
    const panesCount = panes.length;
    let leftToAllocate = 100;
    let definedSizesCount = 0;
    let undefinedSizesNotReadyCount = 0;
    let undefinedSizesSum = 0;
    let ungrowable = [];
    let unshrinkable = [];
    for (let i = 0; i < panesCount; i++) {
      const pane = panes[i];
      const sz = pane.sz();
      if (pane.givenSize == null) {
        if (pane.isReady) {
          undefinedSizesSum += sz;
          if (sz >= pane.max())
            ungrowable.push(pane);
          if (sz <= pane.min())
            unshrinkable.push(pane);
        } else {
          undefinedSizesNotReadyCount += 1;
        }
      } else {
        leftToAllocate -= sz;
        definedSizesCount++;
        ungrowable.push(pane);
        unshrinkable.push(pane);
      }
    }
    const undefinedSizesCount = panesCount - definedSizesCount;
    const undefinedSizesReadyCount = undefinedSizesCount - undefinedSizesNotReadyCount;
    let undefinedSizesNotReadySz;
    let undefinedScaleFactor;
    if (undefinedSizesReadyCount > 0) {
      undefinedSizesNotReadySz = undefinedSizesSum / undefinedSizesReadyCount;
      if (undefinedSizesNotReadySz > 0.1 && leftToAllocate > 0.1) {
        undefinedSizesSum += undefinedSizesNotReadyCount * undefinedSizesNotReadySz;
        undefinedScaleFactor = leftToAllocate / undefinedSizesSum;
      } else {
        undefinedSizesNotReadySz = 0;
        undefinedScaleFactor = 1;
      }
    } else {
      undefinedSizesNotReadySz = leftToAllocate / undefinedSizesCount;
      undefinedScaleFactor = 1;
    }
    if (leftToAllocate + undefinedSizesSum > 0.1) {
      leftToAllocate = 100;
      for (let i = 0; i < panesCount; i++) {
        const pane = panes[i];
        if (pane.givenSize == null) {
          const currentSz = pane.isReady ? pane.sz() : undefinedSizesNotReadySz;
          const sz = Math.max(Math.min(currentSz * undefinedScaleFactor, pane.max()), pane.min());
          pane.setSz(sz);
        }
        leftToAllocate -= pane.sz();
      }
      if (Math.abs(leftToAllocate) > 0.1) {
        leftToAllocate = readjustSizes(leftToAllocate, ungrowable, unshrinkable);
      }
    }
    if (!isFinite(leftToAllocate)) {
      console.warn("Splitpanes: Internal error, sizes might be NaN as a result.");
    } else if (Math.abs(leftToAllocate) > 0.1) {
      console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
    }
  }
  function readjustSizes(leftToAllocate, ungrowable, unshrinkable) {
    const panesCount = panes.length;
    const panesSizableCount = panesCount - (leftToAllocate > 0 ? ungrowable.length : unshrinkable.length);
    if (panesSizableCount <= 0) {
      return leftToAllocate;
    }
    const equalSpaceToAllocate = leftToAllocate / panesSizableCount;
    if (panes.length === 1) {
      panes[0].setSz(100);
      leftToAllocate = 0;
    } else
      for (let i = 0; i < panes.length; i++) {
        const pane = panes[i];
        const sz = pane.sz();
        if (leftToAllocate > 0 && !ungrowable.includes(pane)) {
          const newPaneSize = Math.max(Math.min(sz + equalSpaceToAllocate, pane.max()), pane.min());
          const allocated = newPaneSize - sz;
          leftToAllocate -= allocated;
          pane.setSz(newPaneSize);
        } else if (!unshrinkable.includes(pane)) {
          const newPaneSize = Math.max(Math.min(sz + equalSpaceToAllocate, pane.max()), pane.min());
          const allocated = newPaneSize - sz;
          leftToAllocate -= allocated;
          pane.setSz(newPaneSize);
        }
      }
    return leftToAllocate;
  }
  function verifyAndUpdatePanesOrder() {
    var _a;
    const { children } = container;
    let currentPaneIndex = 0;
    let needReorder = false;
    for (let i = 0; i < children.length; i++) {
      const child = children.item(i);
      const isPane = child.classList.contains("splitpanes__pane");
      const isSplitter = child.classList.contains("splitpanes__splitter");
      if (!isPane && !isSplitter) {
        (_a = child.parentNode) == null ? void 0 : _a.removeChild(child);
        console.warn("Splitpanes: Only <Pane> elements are allowed at the root of <Splitpanes>. One of your DOM nodes was removed.");
        return;
      } else if (isPane) {
        if (!needReorder && panes[currentPaneIndex].element !== child) {
          needReorder = true;
        }
        currentPaneIndex++;
      }
    }
    if (needReorder) {
      const newPanes = [];
      for (let i = 0; i < children.length; i++) {
        const child = children.item(i);
        const isPane = child.classList.contains("splitpanes__pane");
        if (isPane) {
          const pane = panes.find((pane2) => pane2.element === child);
          if (pane != null) {
            pane.index = newPanes.length;
            newPanes.push(pane);
          } else {
            console.warn("Splitpanes: Internal error - found a <Pane> elements which isn't tracked.");
          }
        }
      }
      panes = newPanes;
      set_store_value(veryFirstPaneKey, $veryFirstPaneKey = panes.length > 0 ? panes[0].key : void 0, $veryFirstPaneKey);
    }
  }
  const writable_props = [
    "id",
    "horizontal",
    "pushOtherPanes",
    "dblClickSplitter",
    "rtl",
    "firstSplitter",
    "style",
    "theme",
    "class"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<Splitpanes> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(5, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("horizontal" in $$props2)
      $$invalidate(1, horizontal = $$props2.horizontal);
    if ("pushOtherPanes" in $$props2)
      $$invalidate(12, pushOtherPanes = $$props2.pushOtherPanes);
    if ("dblClickSplitter" in $$props2)
      $$invalidate(13, dblClickSplitter = $$props2.dblClickSplitter);
    if ("rtl" in $$props2)
      $$invalidate(14, rtl = $$props2.rtl);
    if ("firstSplitter" in $$props2)
      $$invalidate(15, firstSplitter = $$props2.firstSplitter);
    if ("style" in $$props2)
      $$invalidate(2, style = $$props2.style);
    if ("theme" in $$props2)
      $$invalidate(3, theme = $$props2.theme);
    if ("class" in $$props2)
      $$invalidate(4, clazz = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    KEY,
    onMount,
    onDestroy,
    setContext,
    createEventDispatcher,
    tick,
    afterUpdate,
    writable,
    GatheringRound: GatheringRound_default,
    browser,
    getDimensionName,
    elementRectWithoutBorder,
    getGlobalMousePosition,
    positionDiff,
    getElementRect,
    sumPartial,
    calcComputedStyle,
    id,
    horizontal,
    pushOtherPanes,
    dblClickSplitter,
    rtl,
    firstSplitter,
    style,
    theme,
    clazz,
    dispatch,
    container,
    isReady,
    isAwaitingPaneReset,
    isAfterInitialTimeoutZero,
    isMouseDown,
    isDragging,
    activeSplitter,
    clickedSplitter,
    timeoutId,
    panes,
    isHorizontal,
    showFirstSplitter,
    veryFirstPaneKey,
    activeSplitterElement,
    activeSplitterDrag,
    ssrPaneDefinedSizeSum,
    ssrPaneUndefinedSizeCount,
    ssrRegisterPaneSize,
    onPaneInit,
    onPaneAdd,
    onPaneRemove,
    onPaneClick,
    reportGivenSizeChange,
    isRTL,
    bindEvents,
    unbindEvents,
    isSplitterElement,
    getOrientedDiff,
    getCurrentDimensionName,
    onMouseDown,
    onMouseMove,
    onMouseUp,
    onSplitterClick,
    onSplitterDblClick,
    prepareSizeEvent,
    getCurrentDragPercentage,
    calculatePanesSize,
    doPushOtherPanes,
    getSizeOfPane,
    sumPrevPanesSize,
    sumNextPanesSize,
    findPrevExpandedPane,
    findNextExpandedPane,
    tickAndResetPaneSizes,
    resetPaneSizes,
    equalize,
    readjustSizes,
    verifyAndUpdatePanesOrder,
    $veryFirstPaneKey,
    $showFirstSplitter,
    $isHorizontal
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("horizontal" in $$props2)
      $$invalidate(1, horizontal = $$props2.horizontal);
    if ("pushOtherPanes" in $$props2)
      $$invalidate(12, pushOtherPanes = $$props2.pushOtherPanes);
    if ("dblClickSplitter" in $$props2)
      $$invalidate(13, dblClickSplitter = $$props2.dblClickSplitter);
    if ("rtl" in $$props2)
      $$invalidate(14, rtl = $$props2.rtl);
    if ("firstSplitter" in $$props2)
      $$invalidate(15, firstSplitter = $$props2.firstSplitter);
    if ("style" in $$props2)
      $$invalidate(2, style = $$props2.style);
    if ("theme" in $$props2)
      $$invalidate(3, theme = $$props2.theme);
    if ("clazz" in $$props2)
      $$invalidate(4, clazz = $$props2.clazz);
    if ("container" in $$props2)
      $$invalidate(5, container = $$props2.container);
    if ("isReady" in $$props2)
      isReady = $$props2.isReady;
    if ("isAwaitingPaneReset" in $$props2)
      isAwaitingPaneReset = $$props2.isAwaitingPaneReset;
    if ("isAfterInitialTimeoutZero" in $$props2)
      $$invalidate(6, isAfterInitialTimeoutZero = $$props2.isAfterInitialTimeoutZero);
    if ("isMouseDown" in $$props2)
      $$invalidate(7, isMouseDown = $$props2.isMouseDown);
    if ("isDragging" in $$props2)
      $$invalidate(8, isDragging = $$props2.isDragging);
    if ("activeSplitter" in $$props2)
      activeSplitter = $$props2.activeSplitter;
    if ("clickedSplitter" in $$props2)
      clickedSplitter = $$props2.clickedSplitter;
    if ("timeoutId" in $$props2)
      timeoutId = $$props2.timeoutId;
    if ("panes" in $$props2)
      panes = $$props2.panes;
    if ("isHorizontal" in $$props2)
      $$invalidate(9, isHorizontal = $$props2.isHorizontal);
    if ("activeSplitterElement" in $$props2)
      activeSplitterElement = $$props2.activeSplitterElement;
    if ("activeSplitterDrag" in $$props2)
      activeSplitterDrag = $$props2.activeSplitterDrag;
    if ("ssrPaneDefinedSizeSum" in $$props2)
      ssrPaneDefinedSizeSum = $$props2.ssrPaneDefinedSizeSum;
    if ("ssrPaneUndefinedSizeCount" in $$props2)
      ssrPaneUndefinedSizeCount = $$props2.ssrPaneUndefinedSizeCount;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*horizontal*/
    2) {
      $:
        set_store_value(isHorizontal, $isHorizontal = horizontal, $isHorizontal);
    }
    if ($$self.$$.dirty[0] & /*firstSplitter*/
    32768) {
      $:
        set_store_value(showFirstSplitter, $showFirstSplitter = firstSplitter, $showFirstSplitter);
    }
  };
  return [
    id,
    horizontal,
    style,
    theme,
    clazz,
    container,
    isAfterInitialTimeoutZero,
    isMouseDown,
    isDragging,
    isHorizontal,
    showFirstSplitter,
    veryFirstPaneKey,
    pushOtherPanes,
    dblClickSplitter,
    rtl,
    firstSplitter,
    slots,
    div_binding,
    $$scope
  ];
}
var Splitpanes = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        id: 0,
        horizontal: 1,
        pushOtherPanes: 12,
        dblClickSplitter: 13,
        rtl: 14,
        firstSplitter: 15,
        style: 2,
        theme: 3,
        class: 4
      },
      add_css,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Splitpanes",
      options,
      id: create_fragment2.name
    });
  }
  get id() {
    throw new Error("<Splitpanes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Splitpanes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get horizontal() {
    throw new Error("<Splitpanes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set horizontal(value) {
    throw new Error("<Splitpanes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pushOtherPanes() {
    throw new Error("<Splitpanes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pushOtherPanes(value) {
    throw new Error("<Splitpanes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dblClickSplitter() {
    throw new Error("<Splitpanes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dblClickSplitter(value) {
    throw new Error("<Splitpanes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rtl() {
    throw new Error("<Splitpanes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rtl(value) {
    throw new Error("<Splitpanes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get firstSplitter() {
    throw new Error("<Splitpanes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set firstSplitter(value) {
    throw new Error("<Splitpanes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Splitpanes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Splitpanes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Splitpanes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Splitpanes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Splitpanes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Splitpanes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Splitpanes_default = Splitpanes;

// node_modules/svelte-splitpanes/internal/utils/functions.js
var carefullCallbackGenerator = (callbackObjectGetter, callbackName) => (value) => {
  const callbackObject = callbackObjectGetter();
  if (callbackObject != null) {
    callbackObject[callbackName](value);
  }
};
var carefullCallbackObject = (callbackObjectGetter, callbackNames) => Object.fromEntries(callbackNames.map((cb) => [cb, carefullCallbackGenerator(callbackObjectGetter, cb)]));

// node_modules/svelte-splitpanes/Pane.svelte
var file2 = "node_modules\\svelte-splitpanes\\Pane.svelte";
function create_if_block2(ctx) {
  let t;
  let div;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$veryFirstPaneKey*/
    (ctx[4] !== /*key*/
    ctx[9] || /*$showFirstSplitter*/
    ctx[5]) && create_if_block_1(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", div_class_value = `splitpanes__pane ${/*clazz*/
      ctx[0] || ""}`);
      attr_dev(
        div,
        "style",
        /*style*/
        ctx[3]
      );
      add_location(div, file2, 116, 1, 3944);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t, anchor);
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[22](div);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*carefullClientCallbacks*/
          ctx[11].onPaneClick,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*$veryFirstPaneKey*/
        ctx2[4] !== /*key*/
        ctx2[9] || /*$showFirstSplitter*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*clazz*/
      1 && div_class_value !== (div_class_value = `splitpanes__pane ${/*clazz*/
      ctx2[0] || ""}`)) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*style*/
      8) {
        attr_dev(
          div,
          "style",
          /*style*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[22](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(106:0) {#if !gathering}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let div_class_value;
  let splitterAction_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", div_class_value = "splitpanes__splitter " + /*isSplitterActive*/
      (ctx[2] ? "splitpanes__splitter__active" : ""));
      add_location(div, file2, 112, 2, 3807);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(splitterAction_action = /*splitterAction*/
        ctx[12].call(null, div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*isSplitterActive*/
      4 && div_class_value !== (div_class_value = "splitpanes__splitter " + /*isSplitterActive*/
      (ctx2[2] ? "splitpanes__splitter__active" : ""))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(112:1) {#if $veryFirstPaneKey !== key || $showFirstSplitter}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*gathering*/
  ctx[10] && create_if_block2(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!/*gathering*/
      ctx2[10])
        if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let dimension;
  let style;
  let $isHorizontal;
  let $veryFirstPaneKey;
  let $showFirstSplitter;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pane", slots, ["default"]);
  const { ssrRegisterPaneSize, onPaneInit, clientOnly: clientOnlyContext, isHorizontal, showFirstSplitter, veryFirstPaneKey } = getContext(KEY);
  validate_store(isHorizontal, "isHorizontal");
  component_subscribe($$self, isHorizontal, (value) => $$invalidate(19, $isHorizontal = value));
  validate_store(showFirstSplitter, "showFirstSplitter");
  component_subscribe($$self, showFirstSplitter, (value) => $$invalidate(5, $showFirstSplitter = value));
  validate_store(veryFirstPaneKey, "veryFirstPaneKey");
  component_subscribe($$self, veryFirstPaneKey, (value) => $$invalidate(4, $veryFirstPaneKey = value));
  let { size = null } = $$props;
  let { minSize = 0 } = $$props;
  let { maxSize = 100 } = $$props;
  let { snapSize = 0 } = $$props;
  let { class: clazz = "" } = $$props;
  const key = {};
  const gathering = !browser && hasContext(gatheringKey);
  const { undefinedPaneInitSize } = !gathering ? onPaneInit(key) : {};
  let element2;
  let sz = size ?? undefinedPaneInitSize;
  let isSplitterActive = false;
  let clientCallbacks = void 0;
  const carefullClientCallbacks = browser ? carefullCallbackObject(() => clientCallbacks, [
    "onSplitterDown",
    "onSplitterClick",
    "onSplitterDblClick",
    "onPaneClick",
    "reportGivenSizeChange"
  ]) : void 0;
  const reportGivenSizeChangeSafe = (size2) => {
    if (size2 != sz) {
      carefullClientCallbacks.reportGivenSizeChange(size2);
    }
  };
  const splitterAction = (splitter) => {
    splitter.onmousedown = carefullClientCallbacks.onSplitterDown;
    if ("ontouchstart" in window) {
      splitter.ontouchstart = carefullClientCallbacks.onSplitterDown;
    }
    splitter.onclick = carefullClientCallbacks.onSplitterClick;
    splitter.ondblclick = carefullClientCallbacks.onSplitterDblClick;
  };
  if (gathering) {
    ssrRegisterPaneSize(size);
  } else if (browser) {
    onMount(() => {
      const inst = {
        key,
        element: element2,
        givenSize: size,
        sz: () => sz,
        setSz: (v) => {
          $$invalidate(17, sz = v);
          if (size != null && size != sz) {
            $$invalidate(13, size = sz);
          }
        },
        min: () => minSize,
        max: () => maxSize,
        snap: () => snapSize,
        setSplitterActive: (isActive) => {
          $$invalidate(2, isSplitterActive = isActive);
        },
        isReady: false
      };
      clientCallbacks = clientOnlyContext.onPaneAdd(inst);
    });
    onDestroy(() => {
      clientOnlyContext.onPaneRemove(key);
    });
  }
  const writable_props = ["size", "minSize", "maxSize", "snapSize", "class"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Pane> was created with unknown prop '${key2}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(13, size = $$props2.size);
    if ("minSize" in $$props2)
      $$invalidate(14, minSize = $$props2.minSize);
    if ("maxSize" in $$props2)
      $$invalidate(15, maxSize = $$props2.maxSize);
    if ("snapSize" in $$props2)
      $$invalidate(16, snapSize = $$props2.snapSize);
    if ("class" in $$props2)
      $$invalidate(0, clazz = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    onDestroy,
    hasContext,
    KEY,
    browser,
    gatheringKey,
    getDimensionName,
    carefullCallbackObject,
    ssrRegisterPaneSize,
    onPaneInit,
    clientOnlyContext,
    isHorizontal,
    showFirstSplitter,
    veryFirstPaneKey,
    size,
    minSize,
    maxSize,
    snapSize,
    clazz,
    key,
    gathering,
    undefinedPaneInitSize,
    element: element2,
    sz,
    isSplitterActive,
    clientCallbacks,
    carefullClientCallbacks,
    reportGivenSizeChangeSafe,
    splitterAction,
    dimension,
    style,
    $isHorizontal,
    $veryFirstPaneKey,
    $showFirstSplitter
  });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(13, size = $$props2.size);
    if ("minSize" in $$props2)
      $$invalidate(14, minSize = $$props2.minSize);
    if ("maxSize" in $$props2)
      $$invalidate(15, maxSize = $$props2.maxSize);
    if ("snapSize" in $$props2)
      $$invalidate(16, snapSize = $$props2.snapSize);
    if ("clazz" in $$props2)
      $$invalidate(0, clazz = $$props2.clazz);
    if ("element" in $$props2)
      $$invalidate(1, element2 = $$props2.element);
    if ("sz" in $$props2)
      $$invalidate(17, sz = $$props2.sz);
    if ("isSplitterActive" in $$props2)
      $$invalidate(2, isSplitterActive = $$props2.isSplitterActive);
    if ("clientCallbacks" in $$props2)
      clientCallbacks = $$props2.clientCallbacks;
    if ("dimension" in $$props2)
      $$invalidate(18, dimension = $$props2.dimension);
    if ("style" in $$props2)
      $$invalidate(3, style = $$props2.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*size*/
    8192) {
      $: {
        if (browser && size != null) {
          reportGivenSizeChangeSafe(size);
        }
      }
    }
    if ($$self.$$.dirty & /*$isHorizontal*/
    524288) {
      $:
        $$invalidate(18, dimension = getDimensionName($isHorizontal));
    }
    if ($$self.$$.dirty & /*dimension, sz*/
    393216) {
      $:
        $$invalidate(3, style = `${dimension}: ${sz}%;`);
    }
  };
  return [
    clazz,
    element2,
    isSplitterActive,
    style,
    $veryFirstPaneKey,
    $showFirstSplitter,
    isHorizontal,
    showFirstSplitter,
    veryFirstPaneKey,
    key,
    gathering,
    carefullClientCallbacks,
    splitterAction,
    size,
    minSize,
    maxSize,
    snapSize,
    sz,
    dimension,
    $isHorizontal,
    $$scope,
    slots,
    div_binding
  ];
}
var Pane = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      size: 13,
      minSize: 14,
      maxSize: 15,
      snapSize: 16,
      class: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pane",
      options,
      id: create_fragment3.name
    });
  }
  get size() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minSize() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minSize(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxSize() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxSize(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get snapSize() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set snapSize(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pane_default = Pane;
export {
  Pane_default as Pane,
  Splitpanes_default as Splitpanes
};
//# sourceMappingURL=svelte-splitpanes.js.map
